
Next ={User interface + back end}

User interface -React
Back end
  -REST API
  -GraphQL API
  -Along with database -sqli,primisa

.................................................................................
				Next js
..................................................................................
What is a Next?
 Next is a flexible React framework that gives you building blocks to create fast web applications.

Web Applications:
.................

What is web app?
  Type of distributed app,deployed at server , accessed over network(internet) vi various network protocals like http,tcp,smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Reponse would be document.
=>HTML
 
other responses types
XML,JSON,Documents,images,vidoes.........

What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser,launched in 1992.

The first web server is NeXT computer

The first web page , lanuched http://info.cern.ch/hypertext/WWW/TheProject.html

Types of Web application:

1.Static web applications - 1989 to 1995 (Now a days also people are building this type apps)
   Hard coded html pages , prepared html pages  kept at webserver , the webserver will send those html pages to clients(browsers)

2.Dynamic Content generation application(1996 to till date)
  After 1995, many people thought that how we can use web for biz information system
 how to share biz informations via internet.
 Generally biz data is stored in databases , how to embed data base data into html pages

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.

Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

The first run time was created based on "c" language called "CGI-comman Gate way interface" later instead of c language "PERL" language.

3.Web services-1998 to till date
 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and recive data because html is just user interface document language.
 We need to data to be exechanged, thats where new data model was created called 'XML'
xml based web apps called web services.

soap protocal was created to transfer XML based documents "SOAP based webservices"

After 2005 soap based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...


4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using javascript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, Javascript.
Frameworks build based on SPA

1.Angular js
2.react
3.vue js


.....................................................................................
			  React as SPA lib
.....................................................................................

Reactjs was created by facebook , in order to build SPA applications for browsers.

Advantages of SPA:
1.Pages are created  at client side, so server load is completly removed
2.SPA reduces the lot of phsyical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is senstive to SEO and time-to concept
This is because the browser will recive a large empty HTML page and has to wait until the javascript is loaded before rendering any thing.

The brith of new Technology called  "SSR" -  Server Side Rendering:
..................................................................................
 I need SEO but at the same time, i want to use SPA as well.

We provides first class api to "render"  an SPA app into HTML strings on the server.
This allows server to send back already rendered HTML, allowing end users to see the content immediately while the javascript is being downloaded.

This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.


SSR types:
 =>Partil SSR 
     We have SPA already, but only few pages(index.html) page is pre compiled at server and sent to client , from where client apps(spa) starts working.

Generally React has api called "ReactDOMServer" using this api we have to render html page on node js(express/hapi)
 
 =>Full SSR
     Every thing is compiled at server side , where as client logics like api calls using ajax is done at client side once the app is rendered.

=>Full Stack apps: =>Full SSR(Next.js)
   Using react like apps are built using full stack apps=>Next js

SSG/JAMStack: (Static Site Generation)
......................................

What is Jamstack?
Jamstack is an architectural approach that decouples the web experience layer from data and business logic, improving flexibility, scalability, performance, and maintainability.

Jamstack removes the need for business logic to dictate the web experience.

Just sending HTML pages to the client without preparing htmls pages while requesting.

SSR will prepare html at server side during "request-response  phase/cycle"

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.

.....................................................................................
			   Next js  -SSR and SSG
.....................................................................................

Next js is full stack web framwork built on the top of react core features  to build modern SSG and SSR apps at very fast...

Next js uses "rust based build system" where as react uses web pack build ....
.......................................................................		
Installing Next infrastructure:

System Req:
 ->Node js 16.8 or later
 ->OS - it can be windows, mac or Linux are supported


Two types of installation
1.Automatic installation
   Which setps everything automatically for you.

npx create-next-app@latest



E:\session\IBM\2023\Nov\NextJS>npx create-next-app@latest
Need to install the following packages:
create-next-app@14.0.2
Ok to proceed? (y) y
√ What is your project named? ... my-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
Creating a new Next.js app in E:\session\IBM\2023\Nov\NextJS\my-app.

Using npm.

Initializing project with template: app


Installing dependencies:
- react
- react-dom
- next

...................................................................................
				Project Structure
...................................................................................
package.json
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.0.2"
  }
}


scripts:
 dev: runs next dev to start next.js in development mode
 build: runs next build to build the application for production usage
 start: runs next start to start a next apps in production mode.
 lint: runs next lint to set up next built in eslint configuration.


next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig


compiler configuration:
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}


src/app
  having basic start up files

layout.js
page.js
   landing page is available inside layout.js

public:
  stores static assests such images,fonts,documents
  public dir are accessed inside code using the base URL "/".

How to start dev server

 > npm run dev

 Note: In Next js file names and folder names are conventinally configured.

 In Nextjs file names  and folder names  play very important.

....................................................................................
			 Root File/Root Component
.....................................................................................

In react , there is index.html which is built in ready made file, inside that file only we create DOM tree and we insert

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root">
      
    </div>
  </body>
</html>

here div element is root container element.inside we create DOM tree and insert which is called SPA
  HTML elements are created at client only.
///////////////////////////////////////////////////////////////////////////////////////
Where as SSR , index.html and other html files are created server side.

How to create index.html in Next app?

Since all server side frameworks, html files including root /landing page is created on fly by server runtime(next runtime/engine).

In next js , all pages(html files) are written using "javascript".

We are going to use  react  as primary programming structure to html pages. 

React is component driven lib, so we need to follow the same pattern.

We create components only. In next every thing is component. 

But we have different types of components with respect to user interface .

1.page 
   Page represents  Userinterface like index.html,product.html,customer.html 

2.layout 
   Wrapper which wraps the page.

Note:
 Every Next js application must start with "root Layout".
 you may have nested layout.

 Props:
 .....
 What is prop?
  Prop is way of configurable information to the UI 

 Why prop?
   Props makes UI more reusable .

What can be prop?

1.Data can be prop - string,numbers,boolean,objects,arrays
2.function as prop 
3.UI/component/element  as prop.

<RootLayout>
  <HomePage/>
</RootLayout>
.
.....................................................................................
			                      Pages & Routing
.....................................................................................

The core of next apps are routing.
The skeleton of every app is routing.

Pages:
......
  A page is UI that is unique to a route.
  You can define pages by exporting a component from page.js file to make the route   publicly accessible
  
Create first Page by adding a page.js file inside app directory. -Home Page

By default routing is enabled,automatically, unlike react spas you dont need to specify the routing.

Note: in next js you dont need to configure any routers, routers are mapped against files and folders

http://localhost:3000/  =>Root URL(route) => page.js

  By default root path is mapped against page.js

src/app/page.js

export default function HomePage() {
    return <h1>
        Hello,Welcome to Next js
    </h1>
app/page.js  ----> /

How to define new route and render accordingly?

create a folder that maps to route automatically 


app/about/page.js   => /about
   
export default function About(){
    return <h1>About us</h1>
}

app/dashboard/page.js  ====> /dashboard


export default function DashBoard() {
    return <h1>Dashboard</h1>
}

app/dashboard/settings/page.js     ===> http://localhost:3000/dashboard/settings

....................................................................................
Routing core concepts
....................................................................................

Inside the app directory, folders are used to define routes.

Each folder represents a "route segment" that maps to a "URL" segment. To create nested route, you can nest folders inside each other.

	localhost:3000 /     dashboard /settings
		       |            |              |
		 Root segment     Segment     leaf Segment

How to create segments(eiether root/segement/leaf)?
  A special file called page.js to make route segments publicly accessible.

if you different name other than page.js , it will not be avaible for public access.

 app/dashboard/config/myconfig.js

http://localhost:3000/dashboard/config/myconfig

.....................................................................................
			   Creating UI
.....................................................................................

Special file conventions are used to create UI for each route segment.

File convention
pages -  page.js
layouts - layout.js
routes   - route.js - server side end points
templates  - template.js
loading   ----loading.js
errors    -----error.js,global-error.js,not-found.js 
..............................................................................
Roles of Folders and files:
..........................

1.folder are used to define routes. A route is a single path of nested folders, following the hierarchy from the the root folder down to a final leaf folder that includes a page.js file

2.Files are used to create UI that is shown the route segment
....................................................................................

page.js :  create the unique UI of a route and make the path publicly accessible
  -route.js : create server side apis/endpoints for a route

layout.js:
  Create shared UI for a segement and its children.
  A layout wraps a page or child segement.
 -template.js
     Similar to layout.js execpt  a new component instance is mounted on navigation.
loading.js
   To show progress bar while loading ui, it uses reac Suspense boundary.
 
error.js
  to handle ui errors,internally it uses error boundary
  ->global-errors.js 
      catching errors in the layout layer level
  ->not-found.js
        this is shown when if there is no url segment matches...
....................................................................................
			   Component hierachy
....................................................................................

layout.js
  Every next app must have one layout.js which define root layout.

template.js
   Templates are similar to layouts that wrapy each child layout or page.

error.js 
   React Error boundary - layout level errors

ErrorBoundary:
Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering.

loading.js
   Which loads component in async manner
   Components render sync manner.
Lazy loading:
  load components in delayed manner
React lazy loading is done via Suspense Component

not-found.js :React Error Boundary
    This is component used to handle errors during component load/page


page.js or nestlayout layout.js
   Actual UI is displayed

Component Structure/Hierarchy:
..............................

<Layout>
   <Template>
	<ErrorBoundary fallback={<Error/>}>
	   <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   </Template>	
</Layout>
....................................................................................
			Nested Route component Hierachy
....................................................................................
app/
 page.js
 layout.js
 not-found.js
 template.js
 loading.js
 error.js
 
dashboard
  -layout.js
  -error.js
  -loading.js
  
<Layout>
    <ErrorBoundary fallback={<Error/>}>
	  <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   
</Layout>

app/
 page.js
 layout.js
 not-found.js
 template.js
 loading.js
 error.js
 
dashboard
  -layout.js
  -error.js
  -loading.js
settings
  -layout.js
  -error.js
  -loading.js
  -page.js


dashboard/settings
  
<Layout>
    <ErrorBoundary fallback={<Error/>}>
	  <Suspense fallback={<Loading/>}>
	     <Layout> <!-- settings---!>
		<ErrorBoundary fallback={<Error/>}>
		    <Suspense fallback={<Loading/>}>
			<Page/>
		    </Suspense>
		<ErrorBoundary>
	     <Layout/>
           <Suspense>	
        </ErrorBoundary>
   
</Layout>

...................................................................................
   			 Linking and Navigation
...................................................................................

The Next.js router uses  "Server centric routing with client side navigation

In old next versions there is pages dir which uses client side routing, the App router uses "server centric routing" to algin server components and data fetching on the server. with server centric routing, the client does not have to  download to route map and the request for compoentents can be use to look up routes.
			
Client side Navigation or client Routing:
..........................................
 The pages are transfered from one page to another page using hyper links or there are js apis like router.push method.
 Client navigation done by the browser apis
 Server side navigation done by the server
			
There are two types of components for naviation.

1.Link compoenent - server side navigation
2.useRouter Hook -client side navigation 

Link Components
Props
 ->href -required
 ->replace 
 -prefetch
 -shallow
 -local


	
.......................................................................................
                            Component Classification
........................................................................................

You can classifiy the compoents.

1.infrastructure components
   page,layouts,templates,errors,loading,notfound
infra structure component must follow the rules like folder name and file name conventions.
 eg 
  src/app 
    layout.js  - root layout 
    page.js -> home page 
  src/app/settings 
     -layout.js  -settings layout 
     -page.js - settings page 
2.user components 
  components which make up the ui like products list,productforms,review,payment.......
......................................................................................
                              Rendering 
......................................................................................

Rendering is nothing but page prepartion (html creation)

Rendering can take place on the server or on the client.
It can happen either ahead of time at build time, 
or on every request at runtime. 

With Next. js, three types of rendering methods are available
  
1.Server-Side Rendering, 
2.Static Site generation
   2.1.ISR - Incremental static rendering = Build time + runtime
3.Client-Side Rendering.

Component types:
 Based on Rendering we can classlify the components into two category

 1.Server components 
    Components are rendered at server side 
 2.Client components 
   Components are rendered at client side 

   By default all components are "Server rendered Components".
.......................................................................................
                            Client Components
.......................................................................................

Co location:
  Apart from the special files you can co-locate , other files such as components,css, test files within app folder or nested folder. 

Create simple component and co locate 

review/review.jsx 
import { useState } from "react"

export default function Review() {
    const [like, setLike] = useState(0)

    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
    </>
}

After running/compiling , you get the following error.
You're importing a component that needs useState. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
Learn more: https://nextjs.org/docs/getting-started/react-essentials

   ╭─[E:\session\IBM\2023\Nov\NextJS\my-app\src\app\review\review.jsx:1:1]
 1 │ import { useState } from "react"
   ·          ────────
 2 │ 
 3 │ export default function Review() {
 3 │     const [like, setLike] = useState(0)
   ╰────

Maybe one of these should be marked as a client entry with "use client":
./src\app\review\review.jsx
./src\app\review\page.js

Why this error?
  
 Server not able render the above code, the reason is the code is subject browser rendering that means, client side rendering.


in order to compile we need to use directive , called "use client"

Solution:
"use client"
import { useState } from "react"

export default function Review() {
    const [like, setLike] = useState(0)

    const onLike = () => {
        console.log('onlike')
        setLike(like + 1)
    }
    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
        <button onClick={onLike}>Like</button>
    </>
}
........................................................................................

I have state like below .

state which displays user information 

const user  = {
  id:1,
  name:'Subramanian'
  contact: {
     address: {
        city:'Pune'
     }
  }
}

Here when i click update button, i want to change city from 'Pune' to 'Coimbatore'

Patterns:
 
1.Server component uses client compoent
2.Client uses another another client component
3.Client uses Server component



Server component uses client Component

Client:
review/review.jsx 
"use client"
import { useState } from "react"

export default function Review() {
    const [like, setLike] = useState(0)

    const onLike = () => {
        console.log('onlike')
        setLike(like + 1)
    }
    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
        <button onClick={onLike}>Like</button>
    </>
}
Server: 
review/page.js 
import Review from "./review";

export default function ReviewPage() {
    console.log('Review page')
    return <div>
        <Review />
    </div>
}

Client Uses another Server Component:

if client uses server, server component becomes client so we loose the purpose of server side rendering. - not recommended

Server:
export default function Dislike() {
    console.log('dislike')
    return <h1>Dislike-Server Component</h1>
}
Client:
"use client"
import { useState } from "react"
import Dislike from "./dislike"

export default function Review() {
    const [like, setLike] = useState(0)

    const onLike = () => {
        console.log('onlike')
        setLike(like + 1)

    }
    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
        <button onClick={onLike}>Like</button>
        <hr />
        {/* Using server component inside client component */}
        <Dislike />
    </>
}
....................................................................................
What if client uses server but i dont want loose the server rendering feature -?

  	Pass Server Component  to Client component as "props"

<Client>
	<Server/>
</Client>

client/page.js 
import MyClient from "./myclient"
import MyServer from "./myserver"

export default function ClientPage() {
    return <div>
        <h1>Client Page</h1>
        <MyClient>
            {/* Here we pass server component as prop to child , so that we never loose the server rendering. */}
            <MyServer />
        </MyClient>
    </div>

}
clinet/myclient.js 
"use client"

// import MyServer from "./myserver"

export default function MyClient(props) {
    return <div>
        <h1>Client Component</h1>
        {/* <MyServer /> */}
        {props.children}
    </div>
}
client/myserver.js 
export default function MyServer() {
    return <h1>
        Server Component
    </h1>
}
.......................................................................................

Client uses another Client :
..........................

client/review.jsx 
'use client'

import Like from "./like"

export default function Review() {
    return <div>
        <h1>Review Client</h1>
        <Like/>
    </div>
}
client/like.jsx 
// 'use client'

import { useState } from "react"

export default function Like() {
    const [like, setLike] = useState(0)
    return <div>
        <h2>{like}</h2>
        <h1>Like Client</h1>
    </div>
}
Here ,when client component uses another client component, we dont need to declare nested client with "use client" directive.
but at the same if that client component is used within another server component , we have to declare 'use client' directive.

Use case, when you migrate third party component's libs into Next echo system .
......................................................................................
                            Advanced Routing Patterns 
.......................................................................................
1.Dynamic routing:

 if you want to build page accroding to dynamic parameter, we can use Dynamic routing pattern.

 URL Pattern
 http://localhost:3000/profile/2

 src/app
     |
     profile
      |
      page.js 
      layout.js 
     [id]
       |
       page.js 
       layout.js 
  
eg:
src/app/blog/layout.js 

export default function BlogLayout({ children }) {

    return <div id="bloglayout">
        {children}
    </div>
}
src/app/blog/page.js 

export default function BlogPage(props) {
    return <h1>Blog Page</h1>
}

src/app/blog/[id]/layout.js 

export default function BlogDetailsLayout({ children }) {

    return <div id="blogDeails">
        {children}
    </div>
}
src/app/blog/[id]/page.js 
// export default function BlogPage(props) {
//     return <>
//         <h1>Blog Details Page</h1>
//         <h1>Blog Id {props.params.id}</h1>
//     </>
// }
export default function BlogPage({ params: { id } }) {
    return <>
        <h1>Blog Details Page</h1>
        <h1>Blog Id {id}</h1>
    </>
}
Testing:
 http://localhost:3000/blog/1
 http://localhost:3000/blog/2
 http://localhost:3000/blog/3
 http://localhost:3000/blog/4
////////////////////////////////////////////////////////////////////////////////////////
                          Master details page 
........................................................................................

Master page contains list of items.
Details page page contains information about particular list item. 

Use case : building master page using mock data 

Masterpage:
src/app/todos/page.js

import { TODOS } from "./todos-mock"
import Link from "next/link"

export default function TodosPage() {
    return <div>
        <ul>
            {TODOS.map(todo => {
                return <li>
                    <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                </li>
            })}
        </ul>
    </div>
}
DetailsPage
src/app/todos/[id]/page.js
export default function TodoDetailsPage({ params: { id } }) {
    return <>
        <h1>Todo Details Page</h1>
        <h1>Todo Id {id}</h1>
    </>
}
........................................................................................
                         Catch All Segement Routing Pattern 
.......................................................................................

Dynamic segements can be extened to catch all subsequent segements by adding [...slug].

eg:
 shop
  |
  [...slug]
    
Url Pattern:
 /shop/tops 
 /shop/tops/tshirt
 /shop/dress/men/shirt 

 How to capture parameters ?
 {
  slug:['tops','tshirt','men','shirt']
 }

eg:
 src/app/shop/page.js 
 
export default function ShopPage(){
    return <div>
        <h1>Shop page</h1>
    </div>
}
Testing :
http://localhost:3000/shop 

 src/app/shop/[...slug]/page.js 

 export default function ShopSlugPage({ params }) {
    return <div>
        <h1>Shop Slug Page {JSON.stringify(params)}</h1>
    </div>
}
Testing:
http://localhost:3000/shop/cloths/tops/t-shirts

Shop Slug Page {"slug":["cloths","tops","t-shirts"]}
.....................................................................................
                     Optional Catch All Routing Pattern
.....................................................................................

for eg :
shop
  |
  [...slug]
    |
    page.js 
|
page.js 

let us assume that , if you want to show, /shop, we need shop/page.js file.
What if i dont want that file too.

shop
  |
  [...slug]
    |
    page.js 

Here shop/[...slug]/page.js if i want to reuse this page itself for rendering /shop url pattern too . We use "Optional Catch All Segment Routing Pattern"

syntax:

shop
  |
  [[...slug]]
    |
    page.js 

eg:
 shop
  |
  [[...slug]]
     |
     page.js 
export default function ShopSlugPage({ params }) {
    return <div>
        <h1>Shop Slug Page {JSON.stringify(params)}</h1>
    </div>
}
Testing:
http://localhost:3000/shop 
  => Shop Slug Page {}
http://localhost:3000/shop/cloths/tops/t-shirts 

  =>  Shop Slug Page {"slug":["cloths","tops","t-shirts"]}
.......................................................................................
                       Route Groups - Routing Pattern 
.......................................................................................
if you want to organize the project based on modules/folders but that folder you dont want map against url .
Route Group helps to create such pattersn 

Route groups are created by wrapping folder within paraenthis (YourDomain)


Route Groups can be used to 

-Organize routes without affecting the URL structure.
-Opting-in specific route segement into a layout
-Create multiple route layouts by spilting your apps

eg:
app
 |
(marketing)     market/sales or market/advt
  market
   sales
      page.js
  page.js
   advt  
      page.js 
http://localhost:3000/market/sales 
http://localhost:3000/market/advt 
.......................................................................................
                      Sharing layout for Route Groups 

You can share layout for each group

eg:
app
 |
(marketing)     market/sales or market/advt
  layout.js 
  market
   sales
      page.js
  page.js
   advt  
      page.js 
http://localhost:3000/market/sales 
http://localhost:3000/market/advt 
  
...................................................................................
                       creating mutliple root layouts 
....................................................................................

To create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route groups. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.

src/app/layout.js 
  This layout can be renamed.

Add layout under group:
 src/app/(marketing)/layout.js

 // export default function MarktingLayout({ children }) {
//     return <div id="markinglayout">
//         {children}
//     </div>
// }
export default function MartingLayout({ children }) {
    return <html lang="en">
        <body>
            <div>
                <h1>Marketing - Advt</h1>
                {children}
            </div>
        </body>
    </html>
}
Note:
 if you plan your app entirely with route group, you can remove root layout.js file  
 if you mix routegroup and without routegroup, root layout file is needed.
....................................................................................
                            Parallel Routing 

  Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout.For highly dynamic sections of an app, such as dashboards and feeds on social sites, Parallel Routing can be used to implement complex routing patterns.

  As of now , we have seen within layout, we have rendered only one page .

Component View:
  <Layout>
       <Page/>
  </Layout>
This is default arch .

What if i want to display, multiple pages within layout like below
  <Layout>
       <Page/>
       <Page/>
  </Layout>

What if i want to display, page conditionally using conditional rendering.

  <Layout>
        condition ? <ThisPage> : <ThatPage>
       
  </Layout>

Basic structure:

src/app 
    |
    layout.js - root layout 
    page.js  - root page 
  |
  info 
    |
    layout.js    ->info layout 
    page.js      ->info page 

Here , only info page is inserted into info layout.
now i want to display two pages called team , and analytics within info layout.


Steps:

1.create folder called game
src/app/game
2.create page.js and layout.js

src/app/game/layout.js 
export default function GameLayout(props) {
    return <div id="gamelayout">
         {props.children}
    </div>
}
src/app/game/page.js 
export default function GamePage(props) {
    return <div>
        <h1>Game Page</h1>
    </div>
}
3.in order to implement parallel routing, we need to create folder

@folderName
  |
  page.js
  layout.js 
src/app/game/@team/page.js
export default function TeamPage(props) {
    return <h2>
        Team Page
    </h2>
}
Now if you test 
http://localhost:3000/game/team
The output would be page not found, the reason is you cant access team page publicly, 
Team page must be injected into Team's layout as prop.

src/app/game/@anaylitics/page.js
export default function AnalyticsPage(props) {
    return <h2>
        Analytics  Page
    </h2>
}

Update GameLayout:
export default function GameLayout(props) {
    return <div id="gamelayout">
        {/* Game Page  */}
        {props.children}
        <hr />
        {/* Team Page  props.folderName */}
        {props.team}
        {/* Analytics Page props.folderName */}
        {props.anaylitics}
    </div>
}
Component View:

 <GameLayout>
        </GamePage>
        <TeamPage>
        <AnalyticsPage/>
 </GameLayout>
......................................................................................
.....................................................................................
				Conditional Rendering-Parallel Routing
.....................................................................................

As of now, we have seen how to render multiple pages into a layout.
Now we are going to discuss how to render page or pages into a layout based on condition.
Slot  means portion of UI.
We render a slot based on certain conditions, such as checkbox values,authentication states.

Syntax:
@AdminPanel
@UserPanel

export default function MyLayout(props) {
  const isAdmin = getUser()
   
  return isAdmin ? props.AdminPanel : props.UserPanel

}
eg:

src/app/panel/page.js
export default function PanelPage(props) {
    return <div>
          <h1>Panel Page</h1>
    </div>
}

src/app/panel/@AdminPanel/page.js
export default function AdminPanelPage(props) {
    return <div>
          <h1>AdminPanelPage</h1>
    </div>
}


src/app/panel/@UserPanel/page.js
export default function UserPanelPage(props) {
    return <div>
          <h1>UserPanelPage</h1>
    </div>
}

src/app/panel/layout.js

export default function PanelLayout(props) {
    const isAdmin = false 
    return <div>
         {props.children}
         {isAdmin ? props.AdminPanel : props.UserPanel}
    </div>
}
src/app/panel/page.js
export default function PanelPage(props) {
    return <div>
          <h1>Panel Page</h1>
    </div>
}

Points:
 Parallel routes are created using named slots.
 Slots are defined with the @folderName convention
 Slots are passed as prop to the layout
.......................................................................................
                            Fallback - Unmatched route 
......................................................................................

if you request a route, each route is mapped against page.js, if Unmatched route,means there would not be page.js , instead of throwing 404 page not found error page, we can show "Default page or fallback page which is alternate page"

fallback page can be created at any route level.

src/app
    |
    default.js 
or 

src/app/dashboard 
    |
    settings 
      |
      page.js 
  default.js 

export default function DefaultPage() {
    return <h1>
        Hello
    </h1>
}
.....................................................................................
                          Data fetching 
......................................................................................

Data fetching is nothing but talking to apis particulary REST API OR GraphQL 

Next app can fetch data either from external end points or internal end points, next provides a feature to build rest apis.

Page can talk directly to External api 
Next Page---------------------->External API 

Page can talk to NEXT API which intern calls External API 
Next Page-------------|NEXT API-------->External API 

Page can talk to NEXT API Which talks to databases 
Next Page-------------|NEXT API-------->Databases 
.................................

Fetching Data on the Server:

=>Whenever possible, we recommend fetching data on the server. This allows you to:

=>Have direct access to backend data resources (e.g. databases).

=>Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.

=>Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.
=>Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.
=>Reduce client-server waterfalls.
=>Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

Fetching Data Where It's Needed:

If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor forward props between components. Instead, you can use fetch or React cache in the component that needs the data without worrying about the performance implications of making multiple requests for the same data.


Data fetching patterns:
1.On the server, with fetch
2.On the server, with third-party libraries
3.On the client, via a Route Handler
4.On the client, with third-party libraries.


Fetching Data on the Server with fetch:
.......................................

Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.
React extends fetch to automatically memoize fetch requests while rendering a React component tree.

You can use fetch with async/await in Server Components, in Route Handlers, and in Server Actions.

Eg:

src/app/todos/page.js 

import Link from "next/link"

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}

export default async function TodosPage() {
    const todos = await fetchTodos()
    return <ul>
        {todos.map(todo => {
            return <>
                <li>
                    <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                </li>

            </>
        })}
    </ul>

}
Task:
Build detail page by fetching todo data from server .
/src/app/todos/[id]/page.js 

export default function TodoPage(props) {
    return <div>
        <h1>Todo Id: {props.params.id}</h1>
    </div>
}
.......................................................................................
                          SSG  - Static Site Generation
.......................................................................................

What is SSG ?
  SSG is type of page rendering.
page can be rendered during request time(SSR) or build time(SSG), build and SSR (ISR)

How to implement SSG ?

Step 1: 
override generateStaticParams
  The generateStaticParams function can be used in combination with dynamic route   segments to statically generate routes at build time instead of on-demand at request time.

todos/[id]/page.js 

URL: http://localhost:3000/todos/1 
  When you hit this url , server prepares page when hit the page - Request time .

What if i want access the page, before i hit. page must have been prepared already and kept in server - SSG 

Step: 
Note: SSG pages only served in prod mode 
 npm run build 
 npm start 

eg:

MasterPage:

src/app/todos/page.js

import Link from "next/link"

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}

export default async function TodosPage() {
    //SSR
    const todos = await fetchTodos()
    return <ul>
        {todos.map(todo => {
            return <>
                <li>
                    <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                </li>

            </>
        })}
    </ul>

}

Details Page where we have to write SSG logic 

src/app/todos/[id]/page.js
export default function TodoPage(props) {
    return <div>
        <h1>Todo Id: {props.params.id}</h1>
    </div>
}

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}
//build time page creation.
export async function generateStaticParams() {
    console.log('building')
    const todos = await fetchTodos()
    return todos.map(todo => {
        let id = todo.id.toString()
        return {
            id: id
        }
    })
}

Starting building:
npm run build

npm run build

> data-fetching@0.1.0 build
> next build

   ▲ Next.js 14.0.3

 ✓ Creating an optimized production build
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
   Collecting page data  ...building
fetching...
 ✓ Collecting page data
   Generating static pages (22/206) [=== ]
fetching...
 ✓ Generating static pages (206/206)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    139 B            84 kB
├ ○ /_not-found                          876 B          84.7 kB
├ ○ /todos                               6.91 kB        90.8 kB
└ ● /todos/[id]                          140 B            84 kB
    ├ /todos/1
    ├ /todos/2
    ├ /todos/3
    └ [+197 more paths]
+ First Load JS shared by all            83.9 kB
  ├ chunks/472-b67f79dbdd2c1fe1.js       28.7 kB
  ├ chunks/fd9d1056-7b52db27cfdaff1f.js  53.3 kB
  ├ chunks/main-app-25cf34c8082530c3.js  219 B
  └ chunks/webpack-d9f8a4f0dd52fadf.js   1.64 kB


○  (Static)  prerendered as static content
●  (SSG)     prerendered as static HTML (uses getStaticProps)
.......................................................................................
                          Client Side Data Fetching

Patterns:

1.using "fetch" api 
2.using "third party" api  - axios

1.Fetching Data on the Client with Route Handlers(built in api)
..................................................

  If you need to fetch data in a client component, you can call a Route Handler from the client. 
  Route Handlers execute on the server and return the data to the client. This is useful when you don't want to expose sensitive information to the client, such as API tokens.

2.Fetching Data on the client without Route Handler 

If you need to fetch data in a client component, you dont need call a Route Handler from the client. 
 
3.Fetching Data on the Client with third-party libraries:

You can also fetch data on the client using a third-party library such as SWR or React Query

Eg: 
Client component using fetch directly:
......................................

src/app/user/page.js 
import User from "./user"
export default function UsersPage() {
    return <div>
        <h1>Users Page</h1>
        <User></User>
    </div>
}
//client component 
src/app/user/user.jsx 

'use client';
async function getUsers() {
    const url = `https://jsonplaceholder.typicode.com/users`
    const res = await fetch(url)
    if (!res.ok) {
        throw new Error('data is not available')
    }
    return res.json()
}
export default async function User() {
    const users = await getUsers()
    console.log(users)
    return <div>
        <h1>User</h1>
        <div>
            {users.map(user => {
                return <h2>{user.username}</h2>
            })}
        </div>
    </div>
}

Client with thrid party like axios :
steps:
1.just install third party libs like npm install axios 
2.you can use axios function to invoke apis .

Note:
 Whether you are using fetch or axios , the call is not cached , we need to enable cache 
There are many ways ,react 18 provides cache function , you can use that function but still in experimental mode .
you can wrap code in thrid party libs like "SWR" - Stale-While-invalidate

steps:
npm install swr 

src/app/posts/post.jsx 

'use client'
import useSWR from 'swr'

function fetcher(...args) {
    return fetch(...args).then(res => res.json())
}
export default function Post() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetcher)
    if (error) {
        return <div><h1>Failed to return</h1></div>
    }
    if (isLoading) return <div>Loading....</div>
    return <div>
        {
            data.map(post => {
                return <h4>
                    {post.title}
                </h4>
            })
        }
    </div>
}
src/app/posts/page.js
import Post from "./post";

export default function PostPage() {
    return <div>
        <Post></Post>
    </div>
}
......................................................................................
                            REST API Development 

1.Building Rest api with mock data 
2.Building Rest api with external end points 
3.Building Rest api with database .


route.js is conventional file name for creating rest api .

src/app/api/route.js 
src/app/api/customers/route.js 
   POST,GET 
src/app/api/customers/[id]/route.js 
GET -  GetInformation by id 
PUT - Update By id 
DELETE -Delete by Id 


route.js
  Inside route.js we write route handlers.

export async function HTTPVerb(request){}

eg:
export async function GET(request){}

Supported HTTP Verb:
 GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS
if un supported method is called, Next js will return a 405 method not allowed response.

Object supported:
1.NextRequest  for handling incoming request
2.NextResponse for handling responses


eg:
src/app/api/route.js 
import { NextResponse } from "next/server";

//rest api
export async function GET(request) {
    //send response
    return NextResponse.json({ message: 'welcome to api' })
}

Testing:
http://localhost:3000/api 
.......................................................................................
Rest API with local mock data:

src/app/api/todos/route.js

import { TODOS } from "./todos";
import { NextResponse } from "next/server";

//GET ALL 
export async function GET(request) {
    //send response
    return NextResponse.json(TODOS)
}

//POST operation
export async function POST(request, { params }) {
    // console.log(request)
    const payload = await request.json()
    console.log(payload)
    return NextResponse.json({ message: 'post request' })
}

src/app/api/todos/[id]/route.js 
import { NextResponse } from "next/server";
import { TODOS } from "../todos";

//GET by id 
export async function GET(request, { params }) {
    //send response
    console.log(params)
    const id = params.id
    const todo = TODOS.filter(todo => todo.id === +id)
    return NextResponse.json(todo)
}
//Update by id :Todo you can add array update logic 
export async function PUT(request, { params }) {
    const id = params.id
    return NextResponse.json({ id: 'add update logic here' })
}


//remove by id :Todo you can write array remove logic 
export async function DELETE(request, { params }) {
    //send response
    const id = params.id
    return NextResponse.json({ id: 'add delete logic here' })
}
.....................................................................................
                Building rest api which consumes third party apis 
.....................................................................................

NexApp----UserInterface----------api(routers)----------------->third party api

Note:
 If you are going to talk to third party rest api within route handler use always "fetch" api 

 src/app/api/albums/route.js 
 import { NextResponse } from "next/server";

//rest api
export async function GET(request) {
    //use fetch api to talk to rest end points
    const url = 'https://jsonplaceholder.typicode.com/albums'
    const res = await fetch(url)
    const albums = await res.json();
    //send response
    return NextResponse.json(albums)
}
....................................................................................
    			How to externalize the data
.....................................................................................

In the above example we have hardcoded the full url

const url = 'https://jsonplaceholder.typicode.com/albums'

How to externalize the config data....

We have file called ".env" file

....................................................................................
			  Environment Variables
....................................................................................

Next js comes with built in support for environment variables, which allows you make to your app more flexible.

.env file syntax

.env.environment

.environment is "dev | prod | test"

.env.development
.env.production
.env.test
.env.local

src/app/api/albums/route.js 

import { NextResponse } from "next/server";

const url = `${process.env.HOST}/albums`

//rest api
export async function GET(request) {
    //use fetch api to talk to rest end points
    //const url = 'https://jsonplaceholder.typicode.com/albums'
    const res = await fetch(url)
    const albums = await res.json();
    //send response
    return NextResponse.json(albums)
}
export async function POST(request) {
    const album = await request.json()
    //post data to json place holder api
    const res = await fetch(url, {
        method: 'POST', headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(album)
    })
    //send response
    const newAlbum = await res.json();
    return NextResponse.json(newAlbum)
}

src/app/api/albums/[id]/route.js 
import { NextResponse } from "next/server";

const url = `${process.env.HOST}/albums`

export async function GET(request, { params }) {
    const id = params.id
    const res = await fetch(`${url}/${id}`)
    const album = await res.json();
    //send response
    return NextResponse.json(album)
}

export async function PUT(request, { params }) {
    const { title } = await request.json()
    const id = params.id
    const res = await fetch(`${url}/${id}`, {
        method: 'PUT', headers: {
            'Content-Type': 'application/json'
            , body: {
                //id, userId, title
                //title: title
                title
            }
        }
    })
    //send response
    const updatedAlbum = await res.json()
    return NextResponse.json(updatedAlbum)
}

export async function DELETE(request, { params }) {
    const id = params.id
    const res = await fetch(`${url}/${id}`, {
        method: 'DELETE'
    })
    //send response
    const deletedAlbum = await res.json()
    return NextResponse.json(deletedAlbum)
}
......................................................................................
                            Database Integration 
......................................................................................

Next js can integrate any database including sql and nosql.
in order to talk to the database we need database drivers and apis.
Mostly we recommend using database frameworks called "ORM" - Object Relational Mapping frameworks 

For node js , we have many frameworks 
1.Prisma
2.Sequelize
3.Type ORM 
etc ...

We are going to use "Prisma"

Steps:
1.install Prisma framework 
2.configure Prisma
3.CURD operation within routers 

1.install Prisma
>npx prisma init --datasource-provider sqlite
Need to install the following packages:
prisma@5.6.0
Ok to proceed? (y) y
                                                                                                                    (✔ Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don't forget to add `.env` in it to not commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run npx prisma db pull to turn your database schema into a Prisma schema.
3. Run npx prisma generate to generate the Prisma Client. You can then start querying your database.
.......................................................................................
ORM fundamentals:

Object Relational               Mapping 
 |         |                     |
Entity  (Relational Database)   binding 

In Database program, we use sql queries for creating,inserting,updating,delete 

IN ORM world, sql queries are abstracted by apis like save,findAll,findById,remove,update 
Entity represents "table".

In Prisma Entity is called as "Model".

schema:
 The plan or structure.

Defining models:
model Comment {
  // Fields
}

model Tag {
  // Fields
}

Fields:
model Comment {
  id      Int    @id @default(autoincrement())
  title   String
  content String
}

model Tag {
  name String @id
}
eg:
prisma/schema.prima 

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Define database model
model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  role      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
.............
npx prisma migrate dev --name init
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

Applying migration `20231120071208_init`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20231120071208_init/
    └─ migration.sql

Your database is now in sync with your schema.

Running generate... (Use --skip-generate to skip the generators)

added 2 packages, and audited 25 packages in 3s

3 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

added 2 packages, and audited 27 packages in 24s

3 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

✔ Generated Prisma Client (v5.6.0) to .\node_modules\@prisma\client in 61ms

After running, you will able to see the table structure:

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "role" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
.....................................................................................
                            seeding database 

While app starts, if you want to insert some data , for testing, you can seed database.
This step is not required, which is optional.

prisma/seed.mjs 
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
    const user = await prisma.user.upsert({
        where: { email: "admin@admin.com" },
        update: {},
        create: {
            name: "Admin",
            email: "admin@admin.com",
            role: "admin",
        },
    });

    console.log({ user });
}

main()
    .then(() => prisma.$disconnect())
    .catch(async (e) => {
        console.error(e);
        await prisma.$disconnect();
        process.exit();
    });

package.json
{
  "name": "db-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "prisma": {
    "seed": "node prisma/seed.mjs"
  },
  "dependencies": {
    "@prisma/client": "^5.6.0",
    "next": "14.0.3",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "prisma": "^5.6.0"
  }
}
npx prisma db seed
Environment variables loaded from .env
Running seed command `node prisma/seed.mjs` ...
{
  user: {
    id: 'b6d894ce-19f6-43a2-ac77-9b3d10e293f4',
    name: 'Admin',
    email: 'admin@admin.com',
    role: 'admin',
    createdAt: 2023-11-20T07:30:13.805Z,
    updatedAt: 2023-11-20T07:30:13.805Z
  }
}

The seed command has been executed.

src/lib/prisma.js 

import { PrismaClient } from "@prisma/client";
const globalForPrisma = global;
export const prisma = globalForPrisma.prisma ||
    new PrismaClient({
        log: ["query"],
    });
....................................................................................
                         Rest api with Prisma 
....................................................................................
src/app/api/users/route.js 
import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(request) {
    const user = await prisma.user.findMany({});
    if (!user) {
        return new NextResponse("No users");
    }
    return NextResponse.json(user);
}
export async function POST(request) {
    try {
        const json = await request.json();
        const user = await prisma.user.create({
            data: json,
        });
        return new NextResponse(JSON.stringify(user), {
            status: 201,
            headers: { "Content-Type": "application/json" },
        });
    }
    catch (error) {
        if (error.code === "P2002") {
            return new NextResponse("User with email already exists", {
                status: 409,
            });
        }
        return new NextResponse(error.message, { status: 500 });
    }
}
GETBYID,Update,delete 
src/app/user/[id]/route.js 

import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";
//GET BY id 
export async function GET(request, { params }) {
    const id = params.id;
    console.log(id)
    const user = await prisma.user.findUnique({
        where: {
            id,
        },
    });
    if (!user) {
        return new NextResponse("No user with ID found", { status: 404 });
    }
    return NextResponse.json(user);
}
//Update by id

export async function PATCH(request, { params }) {
    const id = params.id;
    let json = await request.json();
    const updated_user = await prisma.user.update({
        where: { id },
        data: json,
    });
    if (!updated_user) {
        return new NextResponse("No user with ID found", { status: 404 });
    }
    return NextResponse.json(updated_user);
}
//remove by id 
export async function DELETE(request, { params }) {
    try {
        const id = params.id;
        await prisma.user.delete({
            where: { id },
        });
        return new NextResponse(null, { status: 204 });
    }
    catch (error) {
        if (error.code === "P2025") {
            return new NextResponse("No user with ID found", { status: 404 });
        }
        return new NextResponse(error.message, { status: 500 });
    }
}
//////////////////////////////////////////////////////////////////////////////////////
                         Caching and ISR 

How to enable data cache? 

in order to implement we use api which returns current local time, so that we can easily understand how caching is working. 
Api:
 "http://worldtimeapi.org/api/timezone/Asia/Kolkata"

src/app/timecache/[city]/route.js 

By default next js caches fetch calls, if you opt out no cache.

Without cache:

src/app/timecache/[city]/route.js 

export default async function CachePage(props) {
    const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata', { cache: 'no-store' })
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

Testing:
http://localhost:3000/timecache/Kolkata
Refresh the browser , see that time is keep on updating, because we have disabled cache.

With Cache - Full cache is enabled:
src/app/timecache/[city]/route.js 

export default async function CachePage(props) {
    const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata')
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}
How to revalidate?

Time Based Revalidation:

1.Configuration as part of fetch api.

src/app/timecache/[city]/route.js 

export default async function CachePage(props) {
const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata', { next: { revalidate: 2 } })
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

2.Configuration as part of page vig "Route Segment config"

src/app/timecache/[city]/route.js 

export const revalidate = 2
export default async function CachePage(props) {
 const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata')
    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
    </>
}

OnDemand Revalidation:
......................

Steps:
1.You have to write rest api , which revalidates cache 
1.1.You can path 
1.2.You can use tag 

src/app/timecache/route.js 

//ISR  = SSG + revalidation

//route segment option
// export const revalidate = 2

export default async function CachePage(props) {
     const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata', { next: { tags: ['collection'] } })
    //const response = await fetch('http://worldtimeapi.org/api/timezone/Asia/Kolkata')
       const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
        {/* <h1>ISR Details page {JSON.stringify(props)}</h1> */}
    </>
}

src/app/api/revalidate/route.js 

import { NextRequest, NextResponse } from 'next/server';
import { revalidatePath, revalidateTag } from 'next/cache';

export async function GET(request) {
    const path = request.nextUrl.searchParams.get('path') || '/timecache/Kolkata';
    const collection =
        request.nextUrl.searchParams.get('collection') || 'collection';
    revalidatePath(path);
    // revalidateTag(collection);
    console.log('revalidated', path, collection);
    // console.log('revalidated', path);
    return NextResponse.json({
        revalidated: true,
        now: Date.now(),
        cache: 'no-store',
    });
}
http://localhost:3000/revalidate
.......................................................................................
                        ISR - Incremental Static Generation
......................................................................................

When you generate page ahead of time using "SSG", during building process also caching is enabled.

Once if the app gone for the production, after that if you want rebuild page you can apply revalidation process. 

ISR  = SSG + Revalidation.

src/app/timecache/[city]/route.js 

Note: you can apply cache revalidatation options either time or OnDemand, in same place you can apply both options.


//ISR  = SSG + revalidation

//route segment option
// export const revalidate = 2

export default async function CachePage(props) {
    const response = await fetch(`http://worldtimeapi.org/api/timezone/Asia/${props.params.city}`, { next: { tags: ['collection'] } });

    const data = await response.json();
    return <>
        <h1>Time Now : {new Date(data.datetime).toLocaleTimeString()} </h1>
        {/* <h1>ISR Details page {JSON.stringify(props)}</h1> */}
    </>
}
export async function generateStaticParams() {
    return [{ city: 'Kolkata' }];
}

src/app/api/revalidate/route.js 

import { NextRequest, NextResponse } from 'next/server';
import { revalidatePath, revalidateTag } from 'next/cache';

export async function GET(request) {
    const path = request.nextUrl.searchParams.get('path') || '/timecache/Kolkata';
    const collection =
        request.nextUrl.searchParams.get('collection') || 'collection';
    // revalidatePath(path);
    revalidateTag(collection);
    console.log('revalidated', path, collection);
    // console.log('revalidated', path);
    return NextResponse.json({
        revalidated: true,
        now: Date.now(),
        cache: 'no-store',
    });
}
.......................................................................................
.................................................................................
			             Loading UI 
..................................................................................

The special file loading.js helps to create meaningful loading UI with React suspense.
With this convention, you can show an instant loading state from the server while the content of a route segment loads, the new content is automatically swapped in once rendering is completed.

steps:
src/app/dashboard/layout.js
export default function DashBoardLayout(props) {
    return <>
      {props.children}
    </>
}
src/app/dashboard/loading.js
export default function Loading() {
    // You can add any UI inside Loading, including a Skeleton.
    return <h2>🌀 Loading...</h2>;
}
src/app/dashboard/components/greeter.jsx

export default function Greeter(props){
   return <>
     <h1>Hello</h1>
   </>
}

src/app/dashboard/page.js
import React  from 'react';

const Welcome = React.lazy(() => {
    return new Promise((resolve, reject) => {
        //lazy loading component: here greeter to be loaded async , meaning that this component to be available only after 5000 ms,
        //during 5000 ms  , we need to show some Spinner,thats where loading.js code 
        //to be used
        setTimeout(resolve, 8000, import('./components/greeter'))
    })
});

export default function DashboardPage(props) {
    return <>
      <h1>Dashboard Page</h1>
      <Welcome/>
    </>
}

Component Structure:

 <Layout>
   <Supsense fallback={<Loading/>}
	<Page/>
   </Suspense>
 </Layout>

 ....................................................................................
	Putting loading status within page : overriding existing loading.js code

Can we add Loader via Suspense Manually,
 Yes, we can add, alway local Suspense takes priority.

export default function DashboardPage(props) {
    return <>
        <h1>Dashboard Page</h1>
        {/* <Welcome /> */}

        <Suspense fallback={<h1>Loading.....</h1>}>
            <Welcome />
        </Suspense>
    </>
}
Recommendation:
 Use the loading.js convention always for route segments as Next.js optimizes this functionality.

 ...................................................................................
			            Streaming
...................................................................................
What is Streaming?
 Before understanding what is streaming, we need to understand how SSR works and its limiatation
 Streaming is going to enchance the SSR limiations.

Steps Involved In SSR:
.....................

1.First , all data for a given page is fetched on the server.

2.The server then renders the HTML page 

3.Once the HTML is ready, the server will send HTML,CSS,javascript for the page are sent to the client.

4.NonInteractive user interface is shown using the generated HTML and CSS In browser

5.Finally React, Hydrates,the user interface to make it interactive


TTFB: Time to First Byte:
........................
Time to First Byte (TTFB) refers to the time between the browser requesting a page and when it receives the first byte of information from the server. This time includes DNS lookup and establishing the connection using a TCP handshake and SSL handshake if the request is made over HTTPS


FCP :First Contentfull Paint
The First Contentful Paint (FCP) metric measures the time from when the page starts loading to when any part of the page's content is rendered on the screen

TTI
Time to Interactive (TTI) is a non-standardized web performance 'progress' metric defined as the point in time when the last Long Task finished and was followed by 5 seconds of network and main thread inactivity.21-Feb-2023

These steps are sequentinal and blocking, meaning that the server only render HTML for a page once all the data has been fetched. 
And on the client side React can only hydrate the UI once the code for all components in the page has been downloaded..

this is traditional process, which degrades the app loading performance
.....................................................................................
		  How to improve loading performance
....................................................................................

SSR with React and Next.js helps improve the perceived loading performance by showing a non interactive page to the user as soon as possible.

Only HTML can be sent once the data fetching is over.


Streaming allows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.

This enables part of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.

How to break down into chunks?

  React mental model is component driven, each component we can treat as chunk.

eg:
  if a component have priority or that dont rely on data can be sent first (eg layouts),so the react can hydration eariler....
 if components has less priority, or depends data to be sent later...

How to implement streaming?
 You have to split code into segments

1.static code which does not depend on data
2.dynamic code which depends on data.

if you wrap any component with "Suspense Boundary" which is async, can be rendered later.

if the component relays on data fetching, delays with timers, delays with network connections......

Streaming Component:
....................

export default function Product(props) { 
   <section>
    <nav><a href="product.html"><a></nav>
    <Suspense fallback={<h1>loading....}>
	 <ProductDetails/>
     <Suspense>
   <section>
	
}

Through suspense we can enable streaming....

1.Streaming server rendering: Progressively rendering html from the server to the client

2.Selective Hydration 
    React prioritizes what components to make interactive first based on user interaction.
.....................................................................................
                    SEO - MetaData injection
......................................................................................

You can inject meta information into page using two patterns 

1.static 
   via metadata object 
eg:

export const metadata = {
  title: ' IBM -MyHome Page',
  description: 'This is Next app'
}
export default function HomePage() {
  return <div>

    <h1>Home Page</h1>
  </div>
}
After running you can inspect html code .
 <html>
  <head>
     <title>IBM-MyhomePage</title>
  </head>
</html>
2.dynamic 
 if you want any dynamic meta data, like title , which need to be filled from api calls 

src/app/todos/[id]/page.js 
export default function TodoPage(props) {
    return <div>
        <h1>Todo Id: {props.params.id}</h1>
    </div>
}

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}
//generating title dynamically
export async function generateMetadata({ params, searchParams }, parent) {
    // read route params
    const id = params.id
    // fetch data
    const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
    const todo = await response.json()
    console.log(todo)
    return {
        title: `Todo - ${todo.id}`
    }
}

//build time page creation.
export async function generateStaticParams() {
    console.log('building')
    const todos = await fetchTodos()
    return todos.map(todo => {
        let id = todo.id.toString()
        return {
            id: id
        }
    })
}
.......................................................................................
                            CSS Integration 

1.Global css 
  styles.css 
2.Module specific css 

src/todos/todos.module.css
.container {
    padding: 20px;
    margin-left: 40px;
}
src/todos/page.js 
import styles from './todos.module.css' 

<div className={styles.container}>
</div>
.....................................................................................
                          Built in UI Components 
.....................................................................................
1.Image 
2.Font 
Note : Image and Font componets are optimized for server rendering.
....................................................................................

What is GraphQL?
	GraphQL is a "new API" standard that provides a more efficient, powerful and flexible alternative to REST.

API:
 Appliation programming interface : Entry and exit point for data access.

How apis are represented /encapsulated?
 inside objects

Types of apis:
 1.local api
	api which is part of single runtime- jvm
 2.remote api
       rpc
	 -webservices -  rest api,soap api
         -rpi - grpc
         -tcp based apps
         -smtp based app
       etc...

REST:
   REST has not been designed to be user centric rather than data centric...

if you define any api, which returns data set eg: if you query an api called products

products may have so many fields, i dont want all fields which exposed by the api...

GET  /api/products

 =>[{
  ...
 }]

At its core, GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API.

Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.

GraphQL - A Query Language for APIs
Most applications today have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs.

GraphQL is often confused with being a database technology. This is a misconception, GraphQL is a query language for APIs - not databases. In that sense it’s database agnostic and effectively can be used in any context where an API is used.


A more efficient Alternative to REST
....................................

REST has been a popular way to expose data from a server. When the concept of REST was developed, client applications were relatively simple and the development pace wasn’t nearly where it is today. REST thus was a good fit for many applications. However, the API landscape has radically changed over the last couple of years. In particular, there are three factors that have been challenging the way APIs are designed:

1. Increased mobile usage creates need for efficient data loading
Increased mobile usage, low-powered devices and sloppy networks were the initial reasons why Facebook developed GraphQL. GraphQL minimizes the amount of data that needs to be transferred over the network and thus majorly improves applications operating under these conditions.

2. Variety of different frontend frameworks and platforms
The heterogeneous landscape of frontend frameworks and platforms that run client applications makes it difficult to build and maintain one API that would fit the requirements of all. With GraphQL, each client can access precisely the data it needs.

3. Fast development & expectation for rapid feature development
Continuous deployment has become a standard for many companies, rapid iterations and frequent product updates are indispensable. With REST APIs, the way data is exposed by the server often needs to be modified to account for specific requirements and design changes on the client-side. This hinders fast development practices and product iterations.
.....................................................................................
			  How to begin with GraphQL


GraphQL is platform and language independant.

GraphQL Can be classified into two category

1.Client side - How to send data(Request) to the GraphQL server.
  in order to send data from the client face book published one spec

called
   "GraphQL Query language spec"

2.Server side - How to build graph(object tree) from the data sources
    "GraphQL Schema language spec"

.....................................................................................
			  GraphQL request and response model.



Declarative Programming:

What you write, you have to get the same structure.

The Query request is more readable,declarative. WHich micics the javascript object literal syntax.

js object:

 let user =  {
     id:1,
     name:'joe'
     friends: [
        'bar','foo'
     ]
  } 

GraphQL Request payload : GraphQL Query

GraphQL Client 

POST /endpoint

  {
     id
     name
     friends { -----------------------------> GraphQLServer
        name
     }
  } 

 {
     id
     name
          -----------------------------> GraphQLServer    
 } 
                        

Response:JSON
 {
     "id":1,
     "name":"joe"
     "friends": [      <----------------------------- GraphQLServer
        "bar","foo"
     ]
  } 
..............................................................................................
				 REST AND CURD

Operations Type

GET ------Read
POST -----CREATE
PUT ------UPDATE
DELETE----Remove
.....................................................................................

.............................................................................................
				GRAPHQL And CURD


GraphQL uses only URL which exposes Service


  {
     id
     name
     friends { -----------HTTP POST------------------> GraphQLServer
        name
     }
  } 

Operation Types:

1.Query === GET request in HTTP server
  read
2.mutation === HTTP POST,PUT,DELETE
  create,update,delete
3.subscription
   Streaming

query - a read only fetch
mutation- a write followed by read
subscription- a long live request that fetches data in response to source events.

.................................................................................
			 Graphql Query language - Spec
.....................................................................................

Client Side development:
 In this module, we are going to learn how to send request(graphql) request to graphql server..

Syntax:

1.Selection set

selectionSet: {
 Selection
}

Selection:
 fields
 Fragment Spread
 inline fragament

SelectionSet : What type of operations (query,mutation,subscription)

Read:

query  {
    fields
    Fragment Spread
   inline fragament
}

fields: could be what are the data you are expecting from the server
eg:User information 
in the server user information could be many fields
 firstName,lastName,id,age,city,state,status,pic,stars,ranking....

field List :
 You are asking the server that , hey i want only these fields

query  {
   id
   firstName  ====>POST request=========/url===>GraphQLServer==>Execute api
   lastName   <====response would be json
}
Create,Update,Remove: Mutation

mutation createUser(params) { 
  user
}
mutation updateUser(params) { 
  user
}
mutation removeUser(params) { 
  user
}

Streaming: (read with Streaming)

subscription  getStockQuote (params){
  name
  price
  qty
}
.....................................................................................
			  How to learn graphql query language

in order to work with query language we need graphql server, if you dont have local graphql server we can use mock apis

Fake api servers
https://graphqlzero.almansi.me/#example-top
https://countries.trevorblades.com/
 
Tools to test graphql end points
1.Client tools
 playground
 https://www.apollographql.com/docs/apollo-server/v2/testing/graphql-playground/
 postman

Core concepts:
=>fields
=>arguments
=>aliases
=>fragments
=>variables
=>directives
=>Mutations
=>inline fragments

Fiedls:
  At its simplest, GraphQL is about asking for specific fields on objects.

Lets start by looking at a very simple query and the result we get when we run it.
Simple Query:

query {
  countries {
    code
    name
  }
}
query is name of the operation - read 
"countries" is api name from the server   - function countries(){} - returns object-enity

"code,name" are fields (variables)

Simple Query:

query {
  countries {
    code
    name
  }
}
Sample response:
  "data": {
    "countries": [
      {
        "code": "AD",
        "name": "Andorra"
      },
      {
        "code": "AE",
        "name": "United Arab Emirates"
      },
      {
        "code": "AF",
        "name": "Afghanistan"
      },
      {
        "code": "AG",
        "name": "Antigua and Barbuda"
      },
      {
        "code": "AI",
        "name": "Anguilla"
      },
      {
        "code": "AL",
        "name": "Albania"
      },
      {
        "code": "AM",
        "name": "Armenia"
      },
      {
        "code": "AO",
        "name": "Angola"
      },
      {
        "code": "AQ",
        "name": "Antarctica"
      },
      {
        "code": "AR",
        "name": "Argentina"
      },
      {
        "code": "AS",
        "name": "American Samoa"
      }
]
Short cut:
 we dont need to specificy query keyword
{
  countries {
    code
    name
  }
}
More fields:
 How do we know that the api has more fields?
In the playground, we can see docs in the playground

 {
    countries {
        name
        code
        native
        capital
        currency
    }
}

Inside Graphql server, the above fields are encapulated inside object.
Object property may nest other objects.

How to query nested values?

 {
    countries {
        name
        code
        native
        capital
        currency
        continent {
            name
        }
    }
}

We can use method name syntax
 query getAllCountries {
    countries {
        name
        code
        native
        capital
        currency
        continent {
            name
        }
    }
}
We will see where method syntax is useful.

.....................................................................................
			   Arguments
.....................................................................................

What if i want to get data based  on some condition or conditions?

Synax:

 query getCountryByCode {
     country(code:"US"){
          name
          capital
          currency
          phone
     }
     continent(code:"AS") {
         name
     }
}
Here code is variable , "US" is value

Arg can be static or dynamic arg

Static means passing hardcoded value..

 query getCountryByCode {
     country(code:"US"){
          name
          capital
          currency
          phone
     }
     continent(code:"AS") {
         name
     }
}
...................................................................................
			 Dynamic parameters and arguments -Variables
...................................................................................

Variables:
 Variables are place holders to have dynamic values.
 In case of clients app,you may select values from the drop down or from text field

Variables are introduced in graphql via "$VariableName"

Steps: 
1.replace static values in the query with $variable
2.Declare the variable ($VariableName) as part of the query header

Static
 query getCountryByCode {
     country(code:"US"){
          name
          capital
          currency
          phone
     }
     
}
Dynamic
 query getCountryByCode($variableName:DataType) {
     country(code:$variableName){
          name
          capital
          currency
          phone
     }
     
}
 query getCountryByCode($code:ID!) {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}
How to pass values to this Query?
 Via Query variables in playground.

{
    "code":"IN"
}
Response:
{
    "data": {
        "country": {
            "name": "India",
            "capital": "New Delhi",
            "currency": "INR",
            "phone": "91"
        }
    }
}
...................................................................................
			Default Arg
....................................................................................

What if i dont send the query variable as input, we can substitue default value

 query getCountryByCode($code:ID!="IN") {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}

if you pass  country code, you will get response
{
    "code":"US"
}
Response:

{
    "data": {
        "country": {
            "name": "United States",
            "capital": "Washington D.C.",
            "currency": "USD,USN,USS",
            "phone": "1"
        }
    }
}
if you dont pass country code
{
    "data": {
        "country": {
            "name": "India",
            "capital": "New Delhi",
            "currency": "INR",
            "phone": "91"
        }
    }
}
....................................................................................
			Short cut :without method Name 
 query ($code:ID!="IN") {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}
Recommendation : having method name for more readablity.

 query getCountryByCode($code:ID!="IN") {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}
What can be parameter or arg types?

1.Can be primitives(Scalar types) - ID,String,Int,Float,Enums
2.Can be complex types - Object Types
3.Input type
 Input is special complex type, used to represent input parameters.
 Input types are very usefull incase of mutation

I want to get Language information.

query getlanguageInfo($filter:LanguageFilterInput) {
    languages(filter:$filter) {
        code 
        name
        native
        rtl
    }
}

After execution , you will get all language info

{
    "data": {
        "languages": [
            {
                "code": "af",
                "name": "Afrikaans",
                "native": "Afrikaans",
                "rtl": false
            },
            {
                "code": "am",
                "name": "Amharic",
                "native": "አማርኛ",
                "rtl": false
            },
            {
                "code": "ar",
                "name": "Arabic",
                "native": "العربية",
                "rtl": true
            },
            {
                "code": "ay",
                "name": "Aymara",
                "native": "Aymar",
                "rtl": false
            },
            {
                "code": "az",
                "name": "Azerbaijani",
                "native": "Azərbaycanca / آذربايجان",
                "rtl": false
            },
            {
                "code": "be",
                "name": "Belarusian",
                "native": "Беларуская",
                "rtl": false
            },
            {
                "code": "bg",
                "name": "Bulgarian",
                "native": "Български",
                "rtl": false
            }
]

After giving query variable:

{
    "filter": {
        "code" : {
            "eq" : "en"
        }
    }
}

Response :
{
    "data": {
        "languages": [
            {
                "code": "en",
                "name": "English",
                "native": "English",
                "rtl": false
            }
        ]
    }
}
...................................................................................
			Multiple arg variables
...................................................................................

Multiple Variables:
....................

query getProfile($id:Int,$withFriends:Boolean=false) {

     user(id:$id,withFriends:$withFriends) {
	  name
          pic
      }
}
Passing values:
{"id":1 , "withFriends" : true}
{"id":2 }
.....................................................................................	
                       Alises
....................................................................................

Filed Alises gives dummy name for keys..

Syntax:
 without Aliases:

query { 
  user(id:1){
    id 
    name
  }
}
Response:
{
  "data": { 
    "user": {
	"id":1
         "name":"Subramanian"
    }
  }
}

With Alises:

query { 
  subramanian:user(id:1){
    id 
    name
  }
}
Response:
{
  "data": { 
    "subramanian": {
	"id":1
         "name":"Subramanian"
    }
  }
}
eg:
query getlanguageInfo($filter:LanguageFilterInput) {
    englishLanguage:languages(filter:$filter) {
        code 
        name
        native
        rtl
    }
}
{
    "data": {
        "englishLanguage": [
            {
                "code": "en",
                "name": "English",
                "native": "English",
                "rtl": false
            }
        ]
    }
}
.....................................................................................
			Fragements : Resuable Selection Set
.....................................................................................

Without fragement:
...................

query {
   user(id:2){
      friends {
	id 
        name
        pic
      }
      mutualfriends {
	id 
        name
        pic
      }
   }
}
Here friends and mutual friends are having same set of data
...................................................................................
With Fragements:
...............
query {
   user(id:2){
      friends {
	...friendsFields
      }
      mutualfriends {
	...friendsFields
      }
   }
}

fragement friendsFields on User{
        id 
        name
        pic
}

eg:
query GetA1AndA2Countries {
    a1Countries:countries {
        ...countryInfo
    }
    a2Countries:countries {
        ...countryInfo
    }
}
fragment countryInfo on Country {
    name
    capital
}
Response:
"data": {
        "a1Countries": [
            {
                "name": "Andorra",
                "capital": "Andorra la Vella",
                "__typename": "Country"
            },
            {
                "name": "United Arab Emirates",
                "capital": "Abu Dhabi",
                "__typename": "Country"
            },
            {
                "name": "Afghanistan",
                "capital": "Kabul",
                "__typename": "Country"
            }
	 ],
	 "a2Countries": [
            {
                "name": "Andorra",
                "capital": "Andorra la Vella",
                "__typename": "Country"
            },
            {
                "name": "United Arab Emirates",
                "capital": "Abu Dhabi",
                "__typename": "Country"
            },
            {
                "name": "Afghanistan",
                "capital": "Kabul",
                "__typename": "Country"
            }
	 ]
}
.....................................................................................				   Directives
....................................................................................
Directives are built in functions which provides some utilites.
Directives starts with @DirectiveName(arg:Type)

Built in directives
@include(if:Boolean)
  conditionally include this field in the result if the arg is true
@skip(if:Boolean)
   conditionally exclude this field in the result if the arg is true

query getProfile($id:Int,$withFriends:Boolean=false){ 
	
     user(id:$id) {
	name
	pic
	friends @include(if:$withFriends){
		name
	}
     }  
      

}

Query Variable:
 {"id":5, "withFriends":true}

eg:
query getLanguage($code:ID!,$rtl:Boolean!) {
    language(code:$code){
        name 
        native @include(if:$rtl)
    }
}

Query Variable:
{
    "code":"en",
    "rtl":true
}

Response:
{
    "data": {
        "language": {
            "name": "English",
            "native": "English"
        }
    }
}			

False condition:
Query Variable:
{
    "code":"en",
    "rtl":false
}		
Response:
{
    "data": {
        "language": {
            "name": "English"
        }
    }
}

....................................................................................
				Mutations
...................................................................................

How to send payload to create,update,delete
IN REST

POST=>CREATE
PUT=>UPDATE
DELETE=>REMOVE
GET=>READ

Mutations 
........

mutation is keyword used to create,update,remove...

API url :
https://graphqlzero.almansi.me/api

CREATE:
.......
eg:
mutation CreatePost(
  $input: CreatePostInput!
) {
  createPost(input: $input) {
    id
    title
    body
  }
}

Query Variables:
{
  "input": {
    "title": "A Very Captivating Post Title",
    "body": "Some interesting content."
  }
}

Response:

{
    "data": {
        "createPost": {
            "id": "101",
            "title": "A Very Captivating Post Title",
            "body": "Some interesting content."
        }
    }
}
........................

Update :
mutation UpdatePost($id: ID!,$input: UpdatePostInput!) {
  updatePost(id: $id, input: $input) {
    id
    body
  }
}
Query Variable

{
  "id": 1,
  "input": {
    "body": "Some updated content."
  }
}

Response
{
  "updatePost": {
    "id": "1",
    "body": "Some updated content."
  }
}
....................................................................................
Delete :

mutation RemovePost($id: ID!) {
  deletePost(id: $id)
}
Query Variable:

{
  "id": 101
}.
Response:
{
  "deletePost": true
}

...................................................................................
			 Server side : GraphQL schema Language
....................................................................................

How to build rest api?
  According to rest spec,The problems(domain) are represented as "resources"

Resource represents a Object which expose data and api.
eg:CustomerResource,OrderResource,ProductResource.

Resources are identified by URL 
eg:/
	/api/products and Methods are "GET/POST/PUT/DELETE"

How to build graphql applications?
 According to graphql specifications problems are represented as "Schema"
Schema represents domain models.
Domain Models are represetented as Objects | models | entity.

eg:
 Customer,Order,Product.

In Programming side schema is represented as "Objects and its relationship"
Object and its relationship forms "graph" - Object Graph
.....................................................................................
How to start write graphql apps?
   
   In order to begin with, we need learn there is language called "SDL" - Schema definition language.

SDL Core concepts:
.................

1.Type system.
 The type system defines the Platform independent data types and variables which describe what data can be quired by client.


Flow of client and server

query getUserData {
   user {
     name ===>SDL============>Server==>SDL===Entity==>Biz logic(Services)===>Data 									sources
  }
}

Both client and server talks via common language called "SDL" language

SDL provides language independent abstraction.

	     SDL-----|JAVA/js/python/c++ ...

...................................................................................	
		            	How to write schema
....................................................................................

The schema file is saved as "fileName.schema".

Schema is collection of Object types that contain fields.Each field has a type of its own.
A field type can be scalar(primitives Such as Int,String) or it can another object type.eg User can have Address type.

We need to with key word called "type"

type TypeName {
  field:Datatype
}

In SDL, there is root type, every type is dervied from the root type only.

Root Type:

type schema{
  query:Query
  mutation:Mutation
  subscription:Subscription
}
Query Type: contains read api
type Query{
 #api
 greet:String
 name:String
}
type Mutation {
 #api
 save(param:String):String
}
type Subscription {
 #api
 getStockQuote:String
}
....................................................................................
SDL Defines its language and platform independant data types

1.scallar types
2.Custom types/Reference Types/Object types.

1.Scallar types
 Scallares are primitive types in your language.

1.Int -32 bit signed integer
2.String-UTF-8 char sequence
3.Boolean - true or false
4.Float - signed Double
5.ID(Serialized String) - A unique identifier.

2.Custom types
 Similar to classes in Object oriented languages like c++ ,java,C#,Typescript

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean
}

Object can have other objects : Nested Object
  HAS-A relationship or Depedency Injection


type Address {
  city:String
  state:String
  zipCode:String
}

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean
  address:Address
}
...................................................................................
			Handling null and not null
..................................................................................

Client Query with data

{
  name =====> response {name:'Subramanian'}
}


Client Query without data

{
  name =====> response {name:null}
}
null values some times create issues in the client applications, what if i want to return always value without null.

I dont want null value for a given field? How to force the field must have data or must not have null?

=>Not null fields

Syntax:
  fieldName:Type!
! =>Not null

type Address {
  city:String!
  state:String
  zipCode:String
}

type User{
  id:ID!
  firstName:String!
  lastName:String!
  age:Int
  points:Float
  status:Boolean
  address:Address
}
.................................................................................
			Collection - List of similar Values
..................................................................................

A field may have one or more values

fieldName:[DataType]
 Here Datatype can be scalar type or Object type

fieldName:[String] | [Int] | [Float]
fieldName:[Address] [Order] [Items]

Collection can also be not null

fieldName:[String]! | [Int]! | [Float]!
fieldName:[Address]! [Order]! [Items]!
.....................................................................................
			Query Type
.....................................................................................

Query is collection of apis
Query api can accept input and return values

No parameter: only Return
..........................
field:Type

eg:

type Query {
  name:String
  user:User
  users:[User]
}
Client side:Query language 
{
  name
}
{
  user {
   id
   name
  }
}
{
  users {
     user { 
	id 
	 name
     }
  }
}
Parameters, And Return value:
.............................
field:Type

type Query {
   name(name:String,message:String):String
   userById(id:ID):User
   usersByCity(city:String):[User]!
}
.....................................................................................
			 Advanced Types
.....................................................................................

=>Mutation
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
 Write and Read operations where as Query type is read only.

Signature of the Mutation:

type Mutation{
  createUser(id:ID,name:String,lastName:String,age:Int):User
  updateUser(id:ID,user:User):User
  removeUser(id:ID):User
}

in the above example, more no parameters we need to pass, which makes your code more difficult to understand and read thats where we have new type called "INPUT" type.
...................................................................................
			  Input Types
.................................................................................

Input types are special object types that allow you to provide hierachical data as arguments to fields(as apposed to providing only flat scalar args).
type Mutation{
 #Flat scalar args
  createUser(id:ID,name:String,lastName:String,age:Int):User
}

type Address {
  city:String!
  state:String
  zipCode:String
}

type User{
  id:ID!
  firstName:String!
  lastName:String!
  age:Int
  points:Float
  status:Boolean
  address:Address
}

input CreateUserInput{
  id:ID!
  name:String
  lastName:String
  age:Int
}
input CreateUserResponse{
  id:ID!
  name:String
  lastName:String
  age:Int
}

type Mutation{
  createUser(userInput:CreateUserInput!):CreateUserResponse
}
...................................................................................
			   Enums
....................................................................................
An Enum is similar to scalar types, but its legal values are defined in the schema

enum Gender {
  MALE
  FEMALE
  THIRD
}
How to use Enum


type User{
  id:ID!
  firstName:String!
  lastName:String!
  gender:Gender
  age:Int
  points:Float
  status:Boolean
  address:Address
}
.....................................................................................
			  Union and Interfaces
....................................................................................
Union:
  Unions and interfaces abstract graphql types that enables a schema field to return one of multiple object types.

union Media = Image | Video

type Query {
  getMedia:Media
}

Union type must not be scallar type values it must be always object

 union Foo: String | Int => which is wrong
.....................................................................................
                        Interfaces
.....................................................................................

interface represents common fields that multiple objects can include.

interface Book{ 
  title:String!
  author:String!
}

type TechnicalBook implments Book { 
  title:String!
  author:String!
  X:String
}


type StoryBook implments Book { 
  title:String!
  author:String!
  Y:String
}
....................................................................................
			  Custom Scallar

Graphql SDL provides basic core types - Int,String,Boolean,ID,Float
What if i want other types like Date,Time

How to define custom scalar?

scalar Date

type User{
  id:ID!
  firstName:String!
  lastName:String!
  gender:Gender
  dob:Date
  age:Int
  points:Float
  status:Boolean
  address:Address
}
Date if you declare , you wont get date value, rather we need to write logic how date is represented in server side.
....................................................................................
			 Custom Directives
....................................................................................
directive @cacheControl(
  maxAge: Int
  scope: CacheControlScope
) on FIELD_DEFINITION | OBJECT | INTERFACE

Here we create @cacheControl directives, we need to write logic in the server side code..

   ....................................................................................
			GRAPHQL Application dev
.....................................................................................

Requirement:
 1.You must have SDL before starting any code

Graphql application can be written in any language..

Javascript implmentation (runtime is Node.js)

1.graphql.js
  =>Core framework written by facebook 
  =>You can run standalone or on top of  web servers
  =>Express.js is underlying framework
2.Apollo
   =>It is platform for building graphl apps called "SuperGraphs"
   =>It is written on the top of express server with microservice developments.

Components of Apollo(Graphql apps):

1.Apollo Server
2.Schema definitions - SDL
3.Resolvers - Schema Implmenetation - where we write biz logic
4.Datasources- Database or another rest api...
.....................................................................................
 Apollo Project setup:
.....................
Apollo project can be started with typescript or plain javacript: Typescript is mostly recommended..

E:\session\IBM\2023\May\NextJS\>mkdir apollo-gettingstarted
E:\session\IBM\2023\May\NextJS>cd apollo-gettingstarted
E:\session\IBM\2023\May\NextJS\apollo-gettingstarted> npm init --yes
E:\session\IBM\2023\May\NextJS\apollo-gettingstarted> code .
E:\session\IBM\2023\May\NextJS\apollo-gettingstarted> mkdir src


Install depedencies:

npm i @apollo/server graphql

Typescript dependency:

npm i --save-dev typescript @types/node



Steps:

1.Define Schema
2.Write Biz logic based on Schema - Resolvers
3.Start Apollo Server
4.Query data from the client.

Define Schema:
 Schema definition is represented as "Plain String"

Steps:
1.src/index.ts

//Define schema
const typeDefs=`
#Simple Query which returns Hello World
 type Query {
    hello:String    
 }
`
2.Biz logic : write biz logic for Query: resolover 
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        hello() {
            return "Hello World"
        }
    }
    //Mutation
    
    //Subscription
}

3.We need to deploy(Parse schema,bind resolvers)

3.1. import ApolloServer  and create instance

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

3.2.Start web Container and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)


....................................................................................
			Multiple Apis
....................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 type Query {
    hello:String
    greet:String
    hai:String    
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        hello() {
            return "Hello World"
        },
        hai() {
            return 'Hai GraphQL'
        },
        greet() {
            return 'Greet GraphQL'
        }

    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

.....................................................................................
			Object Types and Queries
....................................................................................	import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 
 type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }

 type Query {
   user:User
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        user() {
            //return object
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 10,
                points: 10.5,
                status: true

            }
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query {
  user {
    id
    firstName
    status
  }
}
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "status": true
    }
  }
}
.................................................................................
			Collections
................................................................................	
src/mock-data/users.ts
export const USERS: Array<any> = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 10,
    points: 10.5,
    status: true

},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 34,
    points: 10.5,
    status: true

},
{
    id: 3,
    firstName: 'Murugan',
    lastName: 'Palanisamy',
    age: 58,
    points: 10.5,
    status: true

}
]

	
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { USERS } from "./mock-data/users.js"

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 
 type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }

 type Query {
   user:[User]
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        user() {
            //return object
            return USERS
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)
....................................................................................
....................................................................................
			 Handling Args and Parameters
...................................................................................
How to handle args/parameters?
 A Resolver function takes four positional args

fun(parent,args,contextValue,info){


}
args it is variable going to hold parameters passed by clients.
args value is going to be literal object
How many parameters if you pass, all parameters are stored inside single literal object
....................................................................................
			 Handling Args and Parameters
...................................................................................
How to handle args/parameters?
 A Resolver function takes four positional args

fun(parent,args,contextValue,info){


}
args it is variable going to hold parameters passed by clients.
args value is going to be literal object
How many parameters if you pass, all parameters are stored inside single literal object
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { USERS } from "./mock-data/users.js"

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 type Query {
     hello(name:String):String
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        hello(parent, args, contextValue, info) {
            console.log(args)
            const { name } = args
            // return `Hello ${args.name}`
            return `Hello ${name}`
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
Dynamic variables
query SayHello($name: String) {
  hello(name: $name)
}
Query Variable
{
  "name": "Subramanian"
}
{
  "data": {
    "hello": "Hello Subramanian"
  }
}
....................................................................................
			Handling Complex Args and Parameters


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { USERS } from "./mock-data/users.js"

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 
 type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }
 input UserResponseInput {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }
 type Query {
   users:[User]
   userById(id:ID!):User
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        users() {
            //return object
            return USERS
        },
        //here _ is just convention to skip the arg
        userById(_, args) {
            const { id } = args
            //filter data based on id
            return USERS.find(user => {
                return user.id === +id
            })
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Query:
query Users($userByIdId: ID!) {
  userById(id: $userByIdId) {
    id
    firstName
    lastName
  }
}

QueryVariable:
{
  "userByIdId": 2
}
Response:
{
  "data": {
    "userById": {
      "id": "2",
      "firstName": "Geetha",
      "lastName": "Subramanian"
    }
  }
}

if parameter does not match , it will return null value...
.....................................................................................
			Nested Data Structure
.....................................................................................

I have data Structure

const users = [
  { 
   id:1,
   name:'A',
   email:'a@gmail.com'
   address: {
    city:'b',
    state:'c'
   }
  }
]

Schema:
//Define schema
const typeDefs = `

type User {
   id:ID!
   name:String
   email:String
   address:Address
}
type Address{
    city:String
    state:String
}
type Query {
    users:[User]
}

In database world user and Address would have stored into different tables.
CREATE Table users(id int,name varchar(10),email varchar(20,constraint c primaryKey(id))

CREATE Table address(city varchar(20),state varchar(20),id references users id)
...................................................................................
Mock data:

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]

const ADDRESS = [{
    city: 'Coimbatore',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2 //linking field
},
{
    city: 'HYD',
    state: 'TS',
    id: 3 //linking field
}]

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]

const ADDRESS = [{
    city: 'Coimbatore',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2 //linking field
},
{
    city: 'HYD',
    state: 'TS',
    id: 3 //linking field
}]

//Define schema
const typeDefs = `

type User {
   id:ID!
   name:String
   email:String
   address:Address
}
type Address{
    city:String
    state:String
}
type Query {
    users:[User]
}
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        users() {
            //return object
            return USERS
        },
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query Users {
  users {
    id
    name
    email
    address {
      city
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": null
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": null
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": null
      }
    ]
  }
}
Here address is missing, that means address is only part of schema but not part of the resolver

How to link users with Address?
...................................................................................
			  Resolver Chains
..................................................................................
Resolver chain means coimbing results of one resolve with in nested resolver

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]

const ADDRESS = [{
    city: 'Coimbatore',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2 //linking field
},
{
    city: 'HYD',
    state: 'TS',
    id: 3 //linking field
}]

//Define schema
const typeDefs = `

type User {
   id:ID!
   name:String
   email:String
   address:Address
}
type Address{
    city:String
    state:String
}
type Query {
    users:[User]
}
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        users() {
            //return object
            return USERS
        },
    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            console.log(parent)
            //connect parent with child: connect this address with user 
            return ADDRESS.find(address => {
                //linking field === parent field
                return address.id === parent.id
            })
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query Users {
  users {
    id
    name
    email
    address {
      city
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": {
          "city": "Coimbatore"
        }
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": {
          "city": "BNG"
        }
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": {
          "city": "HYD"
        }
      }
    ]
  }
}
.....................................................................................
....................................................................................
				Mutations
.....................................................................................

How to send data for insert,update,remove.

type Mutation {
  //add apis
}

src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `

type User {
 id:ID!
 name:String
 email:String
}

type Query {
  users:[User]
  user(id:ID!):User
}

input UserInput{
    id:ID!
    name:String
    email:String
}

type AddUserMutationResponse {
    code:String!
    success:Boolean!
    message:String!
}

type Mutation {
   createUser(userInput:UserInput):AddUserMutationResponse
}
`

const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]
//Define Resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        },
        user(_, args) {
            return USERS.find(user => user.id === +args.id)
        }
    },
    //Mutation
    Mutation: {
        //add new User
        createUser(_, args) {
            //call api to insert users
            USERS.push(args.userInput)
            console.log(args.userInput)
            return {
                code: '200',
                success: true,
                message: 'New User added!'
            }
        }
    }

}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Request:
........
mutation ($userInput:UserInput) {
    createUser(userInput: $userInput) {
      code
      message
      success
    }
}

Variable:
{
  "userInput": {
    "id": "100",
    "name": "Foo",
    "email":"foo@gmail.com"
  }
}
Response:
{
  "data": {
    "createUser": {
      "code": "200",
      "message": "New User added!",
      "success": true
    }
  }
}

Coding Challange:
 You have to update User info
 You have to remove User Info
.....................................................................................
			  Union Types
.....................................................................................

How to resolve unions and interfaces?

 union Media = Book | Movie

 type Query {
   allMedia:[Media] # This includes Both Book and Movie Objects
 }

Syntax
query {
  ...on Book { }
  ...on Movie {} 
}

How Apollo server returns data based on Type?

  __resolveType function

    Media: {
        __resolveType(obj, contextValue, info) {
            if (obj.movietitle) {
                return 'Movie' // Type Name Must be String
            }
            if (obj.author) {
                return 'Book' //Type Name Must Be String
            }
            return null
        }
    },

eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
 #Product OutStock or Availablity or Product

 #Product Name is Candy
 type Candy{
   id:String!
   name:String!
   price:Float
 }
 #Status Types
 type OutOfStock {
    restockDate:String
 }
 type RegionUnAvailablity {
    availableRegions: [String!]
 }

 #union type
 union CandyResult = Candy | OutOfStock | RegionUnAvailablity

 type Query {
    candy(id:String!):CandyResult
 }

 `
 //data
const CANDIES = [
    {
        "id": "gummy-bears",
        "name": "Haribo Gummy Bears",
        "price": 100.89,
       
    },
    {
        "id": "sour-patch",
        "name": "Sour-Patch Kids",
        "price": 45.89
    },
    {
        "id": "wonka-nerds",
        "name": "Wonka Nerds",
        "restockDate": "2022-04-10"
    },
    {
        "id": "swirly-pops",
        "name": "Swirly Pops",
        "availableRegions": ["Coimbatore", "Chennai", "Banaglore"]
    }
]
//Define Resolver
const resolvers = {

    //Resolver Type Resolution function
    CandyResult: {
        __resolveType(obj, contextValue, info) {
            //we need to pass unquie fields
            if (obj.restockDate) {
                return 'OutOfStock' // Type Name Must be String
            }
            if (obj.availableRegions) {
                return 'RegionUnAvailablity'
            }
            if (obj.price) {
                return 'Candy'
            }
            return null
        }
    },

    //Query
    Query: {
        candy(_, args) {
            return CANDIES.find(candy => {
                return candy.id === args.id
            })
        }
    }

}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)


Testing:
Query

query Candy($candyId: String!) {
  candy(id: $candyId) {
    ... on Candy {
      id
      name
      price
    }
    ... on OutOfStock {
      restockDate
    }
    ... on RegionUnAvailablity {
      availableRegions
    }
  }
}

Query variables:
{
  "candyId":"swirly-pops"
}
Response:
{
  "data": {
    "candy": {
      "availableRegions": [
        "Coimbatore",
        "Chennai",
        "Banaglore"
      ]
    }
  }
}
Query
{
  "candyId":"wonka-nerds"
}
Response:
{
  "data": {
    "candy": {
      "restockDate": "2022-04-10"
    }
  }
}
Query:
{
  "candyId":"gummy-bears"
}
{
  "data": {
    "candy": {
      "id": "gummy-bears",
      "name": "Haribo Gummy Bears",
      "price": 100.89
    }
  }
}
...................................................................................
				interface
.....................................................................................
An interface also provides program to super type approach similar to union type...
An interface provides a set of fields that multiple objects types can include

type Query {
  myQuery:InterfaceType
}

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
interface Book {
    title: String!
    author: Author!
}
  
type Course {
    name:String
}
type Author {
    name:String
}
type Textbook implements Book {
    title: String!
    author: Author!
    courses: [Course!]!
}
type ColoringBook implements Book {
    title: String!
    author: Author!
    colors: [String!]!
}
  
type Query {
  books: [Book!]!
}
 `
//  const BOOKS = [{
//     title: 'Graphql',
//     courses: [{
//         name: 'IT'
//     }]
// }]
const BOOKS = [{
    title: 'Graphql',
    colors:['Green'] 
}]

//Define Resolver
const resolvers = {

    //Query
    Query: {
        books() {
            return BOOKS;
        }
    },
    Book: {
        __resolveType(book, contextValue, info) {
            console.log(book)
            if (book.courses) {
                return 'Textbook' //must return Implementaton type in String
            }
            if (book.colors) {
                return 'ColoringBook'
            }
            return null
        }
    }


}

const server = new ApolloServer({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query getBooks {
  books {
    __typename
    title
    ... on Textbook {
      courses {
        name
      }
    }
    ... on ColoringBook {
      colors
    }
  }
}

Response:
{
  "data": {
    "books": [
      {
        "__typename": "ColoringBook",
        "title": "Graphql",
        "colors": [
          "Green"
        ]
      }
    ]
  }
}
.....................................................................................
			....................................................................................
				Context and ContextValue
....................................................................................

Context is Object - can be used to share information across application.
Context information can be accessed inside resolvers,plugins,__resolverType with convention name called "contextValue".

Contex Object:
=>To data based connection info
=>Auth and authorization details
=>Data Sources for fetching Data..
etc...

context Function:
 It is function which is part of "ApolloServer"

const MyContext{
   token:String
   dataSource:String
}

const server = new ApolloServer<MyContext>({
    typeDefs,
    resolvers,
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async()=>{
	return {
	   token:'....',
           dataSource:'...'
	
        }
    }
})


 Query: {
        books(parent,args,contextValue,info) {
            contextValue.token...
        }
    },

eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

interface MyContext {
    greeting?: String
}

//Define Schema
const typeDefs = `
type Query {
  hello:String  
}

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        hello(parent, args, contextValue, info) {
            return contextValue.greeting
        }
    }
}

const server = new ApolloServer<MyContext>({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async ({ req, res }) => {
        return {
            greeting: 'Hello GraphQL context'
        }
    }
})
console.log(`Apollo Server is Ready at ${url}`)

query Query {
  hello
}

Response:
{
  "data": {
    "hello": "Hello GraphQL context"
  }
}
.....................................................................................
				Data Sources & Context
...................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"

//Define Schema
const typeDefs = `
 type Book {
    title:String
    author:String
 }
 type Query {
    books:[Book]
 }

`

const BOOKS = [{
    title: 'GraphQl in Action',
    author: 'A'
},
{
    title: 'Apollo in Action',
    author: 'B'
},
{
    title: 'Typescript in Action',
    author: 'C'
},
{
    title: 'Rest in Action',
    author: 'D'
}

]
//Data source 
export class BookDataSource {
    getBooks() {
        return BOOKS
    }
   //save
   //update
   //remove
}

interface MyContext {
    dataSources: {
        booksAPI: BookDataSource
    }
}


//Define Resolver
const resolvers = {
    //Query
    Query: {
        books(parent, args, contextValue, info) {
            return contextValue.dataSources.booksAPI.getBooks()
        }
    }
}

const server = new ApolloServer<MyContext>({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async ({ req, res }) => {
        return {
            dataSources: {
                booksAPI: new BookDataSource()
            }
        }
    }
})
console.log(`Apollo Server is Ready at ${url}`)


Request:
query {
  books {
    title
    author
  }
}

Response:
{
  "data": {
    "books": [
      {
        "title": "GraphQl in Action",
        "author": "A"
      },
      {
        "title": "Apollo in Action",
        "author": "B"
      },
      {
        "title": "Typescript in Action",
        "author": "C"
      },
      {
        "title": "Rest in Action",
        "author": "D"
      }
    ]
  }
}

Code Challange:
Add all the code inside Datasource class
=>addBook
=>removeBook
=>UpdateBook
=>findBookById
....................................................................................
...................................................................................
			Data sources-Fetching Data From Rest
...................................................................................

Steps:
in order to connect with rest api... i am going to expose local rest api

1.Setup local rest api

npm install -g json-server

2.create db.json file in the project root dir
{
    "posts": [
        {
            "id": 1,
            "title": "json-server",
            "author": "typicode"
        }
    ],
    "comments": [
        {
            "id": 1,
            "body": "some comment",
            "postId": 1
        }
    ],
    "profile": {
        "name": "typicode"
    },
    "books": [
        {
            "title": "Harry Potter and the Chamber of Secrets",
            "author": "J.K. Rowling"
        },
        {
            "title": "Jurassic Park",
            "author": "Michael Crichton"
        },
        {
            "title": "Title - index 2",
            "author": "Author - index 2"
        },
        {
            "title": "Title - index 3",
            "author": "Author - index 3"
        },
        {
            "title": "Title - index 4",
            "author": "Author - index 4"
        },
        {
            "title": "Title - index 5",
            "author": "Author - index 5"
        }
    ]
}

3.Run Rest api server
json-server --watch db.json

Test:
http://localhost:3000/books
.....................................................................................
				
GraphQL setup:
.............
Steps:
1.Create Service/API class in order to communicate Rest api
 Apollo provides a special wrapper class to connect with rest apis

npm install @apollo/datasource-rest --save

2.Create Your own Rest api class and sub class of RESTDataSource

import { RESTDataSource } from "@apollo/datasource-rest"

//type class 
export class Book {
    title: string;
    author: string;
}

//Rest Data Source
export class BooksAPI extends RESTDataSource {
    constructor() {
        super()
        this.baseURL = "http://localhost:3000/"
    }
    //apis:biz api
    async getBooks() {
        //http://localhost:3000/books
        return this.get<Book[]>(`books`)
    }
    //save book
    async postBook(book) {
        return this.post<any>(`books`, book).then(resp => resp.data)
    }
}

3.Create Context Type and inject into server

//Context Type:
interface ContextValue {
    dataSources: {
        booksAPI: BooksAPI
    }
}
const server = new ApolloServer<ContextValue>({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async () => {
        return {
            dataSources: {
                booksAPI: new BooksAPI()  // dataSources.booksAPI.getBooks()
            }
        }
    }
})

4.Schema : To fetch data
//Define Schema
const typeDefs = `
type Book {
    title:String
    author:String
}

type Query {
    "GET all Books from the Rest api server"
    books:[Book!]
}

`
5.Resolver:
//Define Resolver
const resolvers = {
    //Query
    Query: {
        async books(parent, args, contextValue, info) {
            const { dataSources } = contextValue
            return dataSources.booksAPI.getBooks()
        }
    }
}

6.Test Server:


query {
  books {
    title
  }
}
Response:
{
  "data": {
    "books": [
      {
        "title": "Harry Potter and the Chamber of Secrets"
      },
      {
        "title": "Jurassic Park"
      },
      {
        "title": "Title - index 2"
      },
      {
        "title": "Title - index 3"
      },
      {
        "title": "Title - index 4"
      },
      {
        "title": "Title - index 5"
      }
    ]
  }
}
................................................................................
   
Post and Update 
...............

import { RESTDataSource } from "@apollo/datasource-rest"
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from "@apollo/server/standalone"


//type class 
export class Book {
    id?: number;
    title?: string;
    author?: string;
}

export class MutationResponse {
    status: string
    data?: Book
}

//Rest Data Source
export class BooksAPI extends RESTDataSource {
    constructor() {
        super()
        this.baseURL = "http://localhost:3000/"
    }
    //apis:biz api
    async getBooks() {
        //http://localhost:3000/books
        return this.get<Book[]>(`books`)
    }
    async book(id: number) {
        return this.get<Book>(`books/${id}`)
    }
    //save book
    async postBook(book: Book) {
        return this.post<Book>(`books`, { body: book }).then(resp => resp)
    }
    async updateBook(bookId: number, book: Book) {
        return this.put<Book>(`books/${bookId}`, { body: book }).then(resp => resp)
    }
}

//Context Type:
interface ContextValue {
    dataSources: {
        booksAPI: BooksAPI
    }
}


//Define Schema
const typeDefs = `
type Book {
    id:Int
    title:String
    author:String
}

#Query
type Query {
    "GET all Books from the Rest api server"
    books:[Book!]
    book(id:Int!):Book
}


#Mutations

input BookInput{
    id:Int
    title:String!
    author:String!
}

type Mutation {
    "POST new Book to the REST API server"
    addBook(input:BookInput):Book
    updateBook(id:ID!,input:BookInput):Book
}

`
//Define Resolver
const resolvers = {
    //Query
    Query: {
        async books(parent, args, contextValue, info) {
            const { dataSources } = contextValue
            return dataSources.booksAPI.getBooks()
        },
        //Book By Id 
        async book(parent, args, contextValue, info) {
            const { dataSources } = contextValue
            const id = +args.id
            return dataSources.booksAPI.book(id)
        }

    },
    Mutation: {
        //create Book
        async addBook(parent, args, contextValue, info) {
            const { input } = args
            return contextValue.dataSources.booksAPI.postBook(input)
        },
        // //update Book
        async updateBook(parent, args, contextValue, info) {
            const { id, input } = args
            return contextValue.dataSources.booksAPI.updateBook(id, input)
        },
        // //remove Book
        // async removeBook(parent, args, contextValue, info) {

        // }
    }
}

const server = new ApolloServer<ContextValue>({
    typeDefs,
    resolvers,
})
//start the webserver and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async () => {
        return {
            dataSources: {
                booksAPI: new BooksAPI()  // dataSources.booksAPI.getBooks()
            }
        }
    }
})
console.log(`Apollo Server is Ready at ${url}`)

....

mutation($updateBookId: ID!, $input: BookInput)  {
    updateBook(id: $updateBookId, input: $input) {
        title
        author
    }
}
.....................................................................................
.....................................................................................
			Graphql Integration with NextJS 13
....................................................................................

Apollo has released "Apollo client Lib with Next.js 13".

Lib:
 This lib now is under experimental, in future it will be stablished..

@apollo/experimental-nextjs-app-support.

Next 13 Compoent types

1.Server Component
2.Client Component

Apollo provides wrapper for both components...

How to start?

1.Create next.js 13 version project 

2.install the dependencies
  
  npm install @apollo/client@alpha  @apollo/experimental-nextjs-app-support

3.Configuration:
 How to talk to GraphQL server?
  GraphQl end point , GraphQL client object

For ServerComponent

projectRootDir/lib/client.js

import { ApolloClient, HttpLink, InMemoryCache } from "@apollo/client";
import { registerApolloClient } from "@apollo/experimental-nextjs-app-support/rsc";

export const { getClient } = registerApolloClient(() => {
  return new ApolloClient({
    cache: new InMemoryCache(),
    link: new HttpLink({
      // uri: "https://countries.trevorblades.com",
      uri: "http://localhost:4000/"
    }),
  });
});

4.Query Data from the GraphQL server...

import { getClient } from "../../lib/client";
import { gql } from "@apollo/client";

//Query creation using "gql function from the Apollo Client"
const query = gql`query getBooks {
      books {
         author
         title
      }        
}`
export default async function Page() {
  const { data: { books } } = await getClient().query({ query });
  return <main>
    <ul>
      {books.map(book => {
        return <li>{book.author} - {'title'} - {book.title} </li>
      })}
    </ul>
  </main>
}
..................................................................................
















