
Next ={User interface + back end}

User interface -React
Back end
  -REST API
  -GraphQL API
  -Along with database -sqli,primisa

.................................................................................
				Next js
..................................................................................
What is a Next?
 Next is a flexible React framework that gives you building blocks to create fast web applications.

Web Applications:
.................

What is web app?
  Type of distributed app,deployed at server , accessed over network(internet) vi various network protocals like http,tcp,smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Reponse would be document.
=>HTML
 
other responses types
XML,JSON,Documents,images,vidoes.........

What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser,launched in 1992.

The first web server is NeXT computer

The first web page , lanuched http://info.cern.ch/hypertext/WWW/TheProject.html

Types of Web application:

1.Static web applications - 1989 to 1995 (Now a days also people are building this type apps)
   Hard coded html pages , prepared html pages  kept at webserver , the webserver will send those html pages to clients(browsers)

2.Dynamic Content generation application(1996 to till date)
  After 1995, many people thought that how we can use web for biz information system
 how to share biz informations via internet.
 Generally biz data is stored in databases , how to embed data base data into html pages

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.

Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

The first run time was created based on "c" language called "CGI-comman Gate way interface" later instead of c language "PERL" language.

3.Web services-1998 to till date
 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and recive data because html is just user interface document language.
 We need to data to be exechanged, thats where new data model was created called 'XML'
xml based web apps called web services.

soap protocal was created to transfer XML based documents "SOAP based webservices"

After 2005 soap based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...


4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using javascript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, Javascript.
Frameworks build based on SPA

1.Angular js
2.react
3.vue js


.....................................................................................
			  React as SPA lib
.....................................................................................

Reactjs was created by facebook , in order to build SPA applications for browsers.

Advantages of SPA:
1.Pages are created  at client side, so server load is completly removed
2.SPA reduces the lot of phsyical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is senstive to SEO and time-to concept
This is because the browser will recive a large empty HTML page and has to wait until the javascript is loaded before rendering any thing.

The brith of new Technology called  "SSR" -  Server Side Rendering:
..................................................................................
 I need SEO but at the same time, i want to use SPA as well.

We provides first class api to "render"  an SPA app into HTML strings on the server.
This allows server to send back already rendered HTML, allowing end users to see the content immediately while the javascript is being downloaded.

This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.


SSR types:
 =>Partil SSR 
     We have SPA already, but only few pages(index.html) page is pre compiled at server and sent to client , from where client apps(spa) starts working.

Generally React has api called "ReactDOMServer" using this api we have to render html page on node js(express/hapi)
 
 =>Full SSR
     Every thing is compiled at server side , where as client logics like api calls using ajax is done at client side once the app is rendered.

=>Full Stack apps: =>Full SSR(Next.js)
   Using react like apps are built using full stack apps=>Next js

SSG/JAMStack: (Static Site Generation)
............

What is Jamstack?
Jamstack is an architectural approach that decouples the web experience layer from data and business logic, improving flexibility, scalability, performance, and maintainability.

Jamstack removes the need for business logic to dictate the web experience.

Just sending HTML pages to the client without preparing htmls pages while requesting.

SSR will prepare html at server side during "request-response  phase/cycle"

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.

.....................................................................................
			   Next js  -SSR and SSG
.....................................................................................

Next js is full stack web framwork built on the top of react core features  to build modern SSG and SSR apps at very fast...

Next js uses "rust based build system" where as react uses web pack build ....
.......................................................................		
Installing Next infrastructure:

System Req:
 ->Node js 16.8 or later
 ->OS - it can be windows, mac or Linux are supported


Two types of installation
1.Automatic installation
   Which setps everything automatically for you.

npx create-next-app@latest



E:\session\IBM\2023\Nov\NextJS>npx create-next-app@latest
Need to install the following packages:
create-next-app@14.0.2
Ok to proceed? (y) y
√ What is your project named? ... my-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias (@/*)? ... No / Yes
Creating a new Next.js app in E:\session\IBM\2023\Nov\NextJS\my-app.

Using npm.

Initializing project with template: app


Installing dependencies:
- react
- react-dom
- next

...................................................................................
				Project Structure
...................................................................................
package.json
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.0.2"
  }
}


scripts:
 dev: runs next dev to start next.js in development mode
 build: runs next build to build the application for production usage
 start: runs next start to start a next apps in production mode.
 lint: runs next lint to set up next built in eslint configuration.


next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig


compiler configuration:
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}


src/app
  having basic start up files

layout.js
page.js
   landing page is available inside layout.js

public:
  stores static assests such images,fonts,documents
  public dir are accessed inside code using the base URL "/".

How to start dev server

 > npm run dev

 Note: In Next js file names and folder names are conventinally configured.

 In Nextjs file names  and folder names  play very important.

....................................................................................
			 Root File/Root Component
.....................................................................................

In react , there is index.html which is built in ready made file, inside that file only we create DOM tree and we insert

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root">
      
    </div>
  </body>
</html>

here div element is root container element.inside we create DOM tree and insert which is called SPA
  HTML elements are created at client only.
///////////////////////////////////////////////////////////////////////////////////////
Where as SSR , index.html and other html files are created server side.

How to create index.html in Next app?

Since all server side frameworks, html files including root /landing page is created on fly by server runtime(next runtime/engine).

In next js , all pages(html files) are written using "javascript".

We are going to use  react  as primary programming structure to html pages. 

React is component driven lib, so we need to follow the same pattern.

We create components only. In next every thing is component. 

But we have different types of components with respect to user interface .

1.page 
   Page represents  Userinterface like index.html,product.html,customer.html 

2.layout 
   Wrapper which wraps the page.

Note:
 Every Next js application must start with "root Layout".
 you may have nested layout.

 Props:
 .....
 What is prop?
  Prop is way of configurable information to the UI 

 Why prop?
   Props makes UI more reusable .

What can be prop?

1.Data can be prop - string,numbers,boolean,objects,arrays
2.function as prop 
3.UI/component/element  as prop.

<RootLayout>
  <HomePage/>
</RootLayout>
.
.....................................................................................
			                      Pages & Routing
.....................................................................................

The core of next apps are routing.
The skeleton of every app is routing.

Pages:
......
  A page is UI that is unique to a route.
  You can define pages by exporting a component from page.js file to make the route   publicly accessible
  
Create first Page by adding a page.js file inside app directory. -Home Page

By default routing is enabled,automatically, unlike react spas you dont need to specify the routing.

Note: in next js you dont need to configure any routers, routers are mapped against files and folders

http://localhost:3000/  =>Root URL(route) => page.js

  By default root path is mapped against page.js

src/app/page.js

export default function HomePage() {
    return <h1>
        Hello,Welcome to Next js
    </h1>
app/page.js  ----> /

How to define new route and render accordingly?

create a folder that maps to route automatically 


app/about/page.js   => /about
   
export default function About(){
    return <h1>About us</h1>
}

app/dashboard/page.js  ====> /dashboard


export default function DashBoard() {
    return <h1>Dashboard</h1>
}

app/dashboard/settings/page.js     ===> http://localhost:3000/dashboard/settings

....................................................................................
Routing core concepts
....................................................................................

Inside the app directory, folders are used to define routes.

Each folder represents a "route segment" that maps to a "URL" segment. To create nested route, you can nest folders inside each other.

	localhost:3000 /     dashboard /settings
		       |            |              |
		 Root segment     Segment     leaf Segment

How to create segments(eiether root/segement/leaf)?
  A special file called page.js to make route segments publicly accessible.

if you different name other than page.js , it will not be avaible for public access.

 app/dashboard/config/myconfig.js

http://localhost:3000/dashboard/config/myconfig

.....................................................................................
			   Creating UI
.....................................................................................

Special file conventions are used to create UI for each route segment.

File convention
pages -  page.js
layouts - layout.js
routes   - route.js - server side end points
templates  - template.js
loading   ----loading.js
errors    -----error.js,global-error.js,not-found.js 
..............................................................................
Roles of Folders and files:
..........................

1.folder are used to define routes. A route is a single path of nested folders, following the hierarchy from the the root folder down to a final leaf folder that includes a page.js file

2.Files are used to create UI that is shown the route segment
....................................................................................

page.js :  create the unique UI of a route and make the path publicly accessible
  -route.js : create server side apis/endpoints for a route

layout.js:
  Create shared UI for a segement and its children.
  A layout wraps a page or child segement.
 -template.js
     Similar to layout.js execpt  a new component instance is mounted on navigation.
loading.js
   To show progress bar while loading ui, it uses reac Suspense boundary.
 
error.js
  to handle ui errors,internally it uses error boundary
  ->global-errors.js 
      catching errors in the layout layer level
  ->not-found.js
        this is shown when if there is no url segment matches...
....................................................................................
			   Component hierachy
....................................................................................

layout.js
  Every next app must have one layout.js which define root layout.

template.js
   Templates are similar to layouts that wrapy each child layout or page.

error.js 
   React Error boundary - layout level errors

ErrorBoundary:
Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering.

loading.js
   Which loads component in async manner
   Components render sync manner.
Lazy loading:
  load components in delayed manner
React lazy loading is done via Suspense Component

not-found.js :React Error Boundary
    This is component used to handle errors during component load/page


page.js or nestlayout layout.js
   Actual UI is displayed

Component Structure/Hierarchy:
..............................

<Layout>
   <Template>
	<ErrorBoundary fallback={<Error/>}>
	   <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   </Template>	
</Layout>
....................................................................................
			Nested Route component Hierachy
....................................................................................
app/
 page.js
 layout.js
 not-found.js
 template.js
 loading.js
 error.js
 
dashboard
  -layout.js
  -error.js
  -loading.js
  
<Layout>
    <ErrorBoundary fallback={<Error/>}>
	  <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   
</Layout>

app/
 page.js
 layout.js
 not-found.js
 template.js
 loading.js
 error.js
 
dashboard
  -layout.js
  -error.js
  -loading.js
settings
  -layout.js
  -error.js
  -loading.js
  -page.js


dashboard/settings
  
<Layout>
    <ErrorBoundary fallback={<Error/>}>
	  <Suspense fallback={<Loading/>}>
	     <Layout> <!-- settings---!>
		<ErrorBoundary fallback={<Error/>}>
		    <Suspense fallback={<Loading/>}>
			<Page/>
		    </Suspense>
		<ErrorBoundary>
	     <Layout/>
           <Suspense>	
        </ErrorBoundary>
   
</Layout>

...................................................................................
   			 Linking and Navigation
...................................................................................

The Next.js router uses  "Server centric routing with client side navigation

In old next versions there is pages dir which uses client side routing, the App router uses "server centric routing" to algin server components and data fetching on the server. with server centric routing, the client does not have to  download to route map and the request for compoentents can be use to look up routes.
			
Client side Navigation or client Routing:
..........................................
 The pages are transfered from one page to another page using hyper links or there are js apis like router.push method.
 Client navigation done by the browser apis
 Server side navigation done by the server
			
There are two types of components for naviation.

1.Link compoenent - server side navigation
2.useRouter Hook -client side navigation 

Link Components
Props
 ->href -required
 ->replace 
 -prefetch
 -shallow
 -local


	
.......................................................................................
                            Component Classification
........................................................................................

You can classifiy the compoents.

1.infrastructure components
   page,layouts,templates,errors,loading,notfound
infra structure component must follow the rules like folder name and file name conventions.
 eg 
  src/app 
    layout.js  - root layout 
    page.js -> home page 
  src/app/settings 
     -layout.js  -settings layout 
     -page.js - settings page 
2.user components 
  components which make up the ui like products list,productforms,review,payment.......
......................................................................................
                              Rendering 
......................................................................................

Rendering is nothing but page prepartion (html creation)

Rendering can take place on the server or on the client.
It can happen either ahead of time at build time, 
or on every request at runtime. 

With Next. js, three types of rendering methods are available
  
1.Server-Side Rendering, 
2.Static Site generation
   2.1.ISR - Incremental static rendering = Build time + runtime
3.Client-Side Rendering.

Component types:
 Based on Rendering we can classlify the components into two category

 1.Server components 
    Components are rendered at server side 
 2.Client components 
   Components are rendered at client side 

   By default all components are "Server rendered Components".
.......................................................................................
                            Client Components
.......................................................................................

Co location:
  Apart from the special files you can co-locate , other files such as components,css, test files within app folder or nested folder. 

Create simple component and co locate 

review/review.jsx 
import { useState } from "react"

export default function Review() {
    const [like, setLike] = useState(0)

    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
    </>
}

After running/compiling , you get the following error.
You're importing a component that needs useState. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
Learn more: https://nextjs.org/docs/getting-started/react-essentials

   ╭─[E:\session\IBM\2023\Nov\NextJS\my-app\src\app\review\review.jsx:1:1]
 1 │ import { useState } from "react"
   ·          ────────
 2 │ 
 3 │ export default function Review() {
 3 │     const [like, setLike] = useState(0)
   ╰────

Maybe one of these should be marked as a client entry with "use client":
./src\app\review\review.jsx
./src\app\review\page.js

Why this error?
  
 Server not able render the above code, the reason is the code is subject browser rendering that means, client side rendering.


in order to compile we need to use directive , called "use client"

Solution:
"use client"
import { useState } from "react"

export default function Review() {
    const [like, setLike] = useState(0)

    const onLike = () => {
        console.log('onlike')
        setLike(like + 1)
    }
    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
        <button onClick={onLike}>Like</button>
    </>
}
........................................................................................

I have state like below .

state which displays user information 

const user  = {
  id:1,
  name:'Subramanian'
  contact: {
     address: {
        city:'Pune'
     }
  }
}

Here when i click update button, i want to change city from 'Pune' to 'Coimbatore'

Patterns:
 
1.Server component uses client compoent
2.Client uses another another client component
3.Client uses Server component



Server component uses client Component

Client:
review/review.jsx 
"use client"
import { useState } from "react"

export default function Review() {
    const [like, setLike] = useState(0)

    const onLike = () => {
        console.log('onlike')
        setLike(like + 1)
    }
    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
        <button onClick={onLike}>Like</button>
    </>
}
Server: 
review/page.js 
import Review from "./review";

export default function ReviewPage() {
    console.log('Review page')
    return <div>
        <Review />
    </div>
}

Client Uses another Server Component:

if client uses server, server component becomes client so we loose the purpose of server side rendering. - not recommended

Server:
export default function Dislike() {
    console.log('dislike')
    return <h1>Dislike-Server Component</h1>
}
Client:
"use client"
import { useState } from "react"
import Dislike from "./dislike"

export default function Review() {
    const [like, setLike] = useState(0)

    const onLike = () => {
        console.log('onlike')
        setLike(like + 1)

    }
    return <>
        <h1>Review Component</h1>
        <h2>Like  {like}</h2>
        <button onClick={onLike}>Like</button>
        <hr />
        {/* Using server component inside client component */}
        <Dislike />
    </>
}
....................................................................................
What if client uses server but i dont want loose the server rendering feature -?

  	Pass Server Component  to Client component as "props"

<Client>
	<Server/>
</Client>

client/page.js 
import MyClient from "./myclient"
import MyServer from "./myserver"

export default function ClientPage() {
    return <div>
        <h1>Client Page</h1>
        <MyClient>
            {/* Here we pass server component as prop to child , so that we never loose the server rendering. */}
            <MyServer />
        </MyClient>
    </div>

}
clinet/myclient.js 
"use client"

// import MyServer from "./myserver"

export default function MyClient(props) {
    return <div>
        <h1>Client Component</h1>
        {/* <MyServer /> */}
        {props.children}
    </div>
}
client/myserver.js 
export default function MyServer() {
    return <h1>
        Server Component
    </h1>
}
.......................................................................................

Client uses another Client :
..........................

client/review.jsx 
'use client'

import Like from "./like"

export default function Review() {
    return <div>
        <h1>Review Client</h1>
        <Like/>
    </div>
}
client/like.jsx 
// 'use client'

import { useState } from "react"

export default function Like() {
    const [like, setLike] = useState(0)
    return <div>
        <h2>{like}</h2>
        <h1>Like Client</h1>
    </div>
}
Here ,when client component uses another client component, we dont need to declare nested client with "use client" directive.
but at the same if that client component is used within another server component , we have to declare 'use client' directive.

Use case, when you migrate third party component's libs into Next echo system .
......................................................................................
                            Advanced Routing Patterns 
.......................................................................................
1.Dynamic routing:

 if you want to build page accroding to dynamic parameter, we can use Dynamic routing pattern.

 URL Pattern
 http://localhost:3000/profile/2

 src/app
     |
     profile
      |
      page.js 
      layout.js 
     [id]
       |
       page.js 
       layout.js 
  
eg:
src/app/blog/layout.js 

export default function BlogLayout({ children }) {

    return <div id="bloglayout">
        {children}
    </div>
}
src/app/blog/page.js 

export default function BlogPage(props) {
    return <h1>Blog Page</h1>
}

src/app/blog/[id]/layout.js 

export default function BlogDetailsLayout({ children }) {

    return <div id="blogDeails">
        {children}
    </div>
}
src/app/blog/[id]/page.js 
// export default function BlogPage(props) {
//     return <>
//         <h1>Blog Details Page</h1>
//         <h1>Blog Id {props.params.id}</h1>
//     </>
// }
export default function BlogPage({ params: { id } }) {
    return <>
        <h1>Blog Details Page</h1>
        <h1>Blog Id {id}</h1>
    </>
}
Testing:
 http://localhost:3000/blog/1
 http://localhost:3000/blog/2
 http://localhost:3000/blog/3
 http://localhost:3000/blog/4
////////////////////////////////////////////////////////////////////////////////////////
                          Master details page 
........................................................................................

Master page contains list of items.
Details page page contains information about particular list item. 

Use case : building master page using mock data 

Masterpage:
src/app/todos/page.js

import { TODOS } from "./todos-mock"
import Link from "next/link"

export default function TodosPage() {
    return <div>
        <ul>
            {TODOS.map(todo => {
                return <li>
                    <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                </li>
            })}
        </ul>
    </div>
}
DetailsPage
src/app/todos/[id]/page.js
export default function TodoDetailsPage({ params: { id } }) {
    return <>
        <h1>Todo Details Page</h1>
        <h1>Todo Id {id}</h1>
    </>
}
........................................................................................
                         Catch All Segement Routing Pattern 
.......................................................................................

Dynamic segements can be extened to catch all subsequent segements by adding [...slug].

eg:
 shop
  |
  [...slug]
    
Url Pattern:
 /shop/tops 
 /shop/tops/tshirt
 /shop/dress/men/shirt 

 How to capture parameters ?
 {
  slug:['tops','tshirt','men','shirt']
 }

eg:
 src/app/shop/page.js 
 
export default function ShopPage(){
    return <div>
        <h1>Shop page</h1>
    </div>
}
Testing :
http://localhost:3000/shop 

 src/app/shop/[...slug]/page.js 

 export default function ShopSlugPage({ params }) {
    return <div>
        <h1>Shop Slug Page {JSON.stringify(params)}</h1>
    </div>
}
Testing:
http://localhost:3000/shop/cloths/tops/t-shirts

Shop Slug Page {"slug":["cloths","tops","t-shirts"]}
.....................................................................................
                     Optional Catch All Routing Pattern
.....................................................................................

for eg :
shop
  |
  [...slug]
    |
    page.js 
|
page.js 

let us assume that , if you want to show, /shop, we need shop/page.js file.
What if i dont want that file too.

shop
  |
  [...slug]
    |
    page.js 

Here shop/[...slug]/page.js if i want to reuse this page itself for rendering /shop url pattern too . We use "Optional Catch All Segment Routing Pattern"

syntax:

shop
  |
  [[...slug]]
    |
    page.js 

eg:
 shop
  |
  [[...slug]]
     |
     page.js 
export default function ShopSlugPage({ params }) {
    return <div>
        <h1>Shop Slug Page {JSON.stringify(params)}</h1>
    </div>
}
Testing:
http://localhost:3000/shop 
  => Shop Slug Page {}
http://localhost:3000/shop/cloths/tops/t-shirts 

  =>  Shop Slug Page {"slug":["cloths","tops","t-shirts"]}
.......................................................................................
                       Route Groups - Routing Pattern 
.......................................................................................
if you want to organize the project based on modules/folders but that folder you dont want map against url .
Route Group helps to create such pattersn 

Route groups are created by wrapping folder within paraenthis (YourDomain)


Route Groups can be used to 

-Organize routes without affecting the URL structure.
-Opting-in specific route segement into a layout
-Create multiple route layouts by spilting your apps

eg:
app
 |
(marketing)     market/sales or market/advt
  market
   sales
      page.js
  page.js
   advt  
      page.js 
http://localhost:3000/market/sales 
http://localhost:3000/market/advt 
.......................................................................................
                      Sharing layout for Route Groups 

You can share layout for each group

eg:
app
 |
(marketing)     market/sales or market/advt
  layout.js 
  market
   sales
      page.js
  page.js
   advt  
      page.js 
http://localhost:3000/market/sales 
http://localhost:3000/market/advt 
  
...................................................................................
                       creating mutliple root layouts 
....................................................................................

To create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route groups. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.

src/app/layout.js 
  This layout can be renamed.

Add layout under group:
 src/app/(marketing)/layout.js

 // export default function MarktingLayout({ children }) {
//     return <div id="markinglayout">
//         {children}
//     </div>
// }
export default function MartingLayout({ children }) {
    return <html lang="en">
        <body>
            <div>
                <h1>Marketing - Advt</h1>
                {children}
            </div>
        </body>
    </html>
}
Note:
 if you plan your app entirely with route group, you can remove root layout.js file  
 if you mix routegroup and without routegroup, root layout file is needed.
....................................................................................
                            Parallel Routing 

  Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout.For highly dynamic sections of an app, such as dashboards and feeds on social sites, Parallel Routing can be used to implement complex routing patterns.

  As of now , we have seen within layout, we have rendered only one page .

Component View:
  <Layout>
       <Page/>
  </Layout>
This is default arch .

What if i want to display, multiple pages within layout like below
  <Layout>
       <Page/>
       <Page/>
  </Layout>

What if i want to display, page conditionally using conditional rendering.

  <Layout>
        condition ? <ThisPage> : <ThatPage>
       
  </Layout>

Basic structure:

src/app 
    |
    layout.js - root layout 
    page.js  - root page 
  |
  info 
    |
    layout.js    ->info layout 
    page.js      ->info page 

Here , only info page is inserted into info layout.
now i want to display two pages called team , and analytics within info layout.


Steps:

1.create folder called game
src/app/game
2.create page.js and layout.js

src/app/game/layout.js 
export default function GameLayout(props) {
    return <div id="gamelayout">
         {props.children}
    </div>
}
src/app/game/page.js 
export default function GamePage(props) {
    return <div>
        <h1>Game Page</h1>
    </div>
}
3.in order to implement parallel routing, we need to create folder

@folderName
  |
  page.js
  layout.js 
src/app/game/@team/page.js
export default function TeamPage(props) {
    return <h2>
        Team Page
    </h2>
}
Now if you test 
http://localhost:3000/game/team
The output would be page not found, the reason is you cant access team page publicly, 
Team page must be injected into Team's layout as prop.

src/app/game/@anaylitics/page.js
export default function AnalyticsPage(props) {
    return <h2>
        Analytics  Page
    </h2>
}

Update GameLayout:
export default function GameLayout(props) {
    return <div id="gamelayout">
        {/* Game Page  */}
        {props.children}
        <hr />
        {/* Team Page  props.folderName */}
        {props.team}
        {/* Analytics Page props.folderName */}
        {props.anaylitics}
    </div>
}
Component View:

 <GameLayout>
        </GamePage>
        <TeamPage>
        <AnalyticsPage/>
 </GameLayout>
......................................................................................
.....................................................................................
				Conditional Rendering-Parallel Routing
.....................................................................................

As of now, we have seen how to render multiple pages into a layout.
Now we are going to discuss how to render page or pages into a layout based on condition.
Slot  means portion of UI.
We render a slot based on certain conditions, such as checkbox values,authentication states.

Syntax:
@AdminPanel
@UserPanel

export default function MyLayout(props) {
  const isAdmin = getUser()
   
  return isAdmin ? props.AdminPanel : props.UserPanel

}
eg:

src/app/panel/page.js
export default function PanelPage(props) {
    return <div>
          <h1>Panel Page</h1>
    </div>
}

src/app/panel/@AdminPanel/page.js
export default function AdminPanelPage(props) {
    return <div>
          <h1>AdminPanelPage</h1>
    </div>
}


src/app/panel/@UserPanel/page.js
export default function UserPanelPage(props) {
    return <div>
          <h1>UserPanelPage</h1>
    </div>
}

src/app/panel/layout.js

export default function PanelLayout(props) {
    const isAdmin = false 
    return <div>
         {props.children}
         {isAdmin ? props.AdminPanel : props.UserPanel}
    </div>
}
src/app/panel/page.js
export default function PanelPage(props) {
    return <div>
          <h1>Panel Page</h1>
    </div>
}

Points:
 Parallel routes are created using named slots.
 Slots are defined with the @folderName convention
 Slots are passed as prop to the layout
.......................................................................................
                            Fallback - Unmatched route 
......................................................................................

if you request a route, each route is mapped against page.js, if Unmatched route,means there would not be page.js , instead of throwing 404 page not found error page, we can show "Default page or fallback page which is alternate page"

fallback page can be created at any route level.

src/app
    |
    default.js 
or 

src/app/dashboard 
    |
    settings 
      |
      page.js 
  default.js 

export default function DefaultPage() {
    return <h1>
        Hello
    </h1>
}
.....................................................................................
                          Data fetching 
......................................................................................

Data fetching is nothing but talking to apis particulary REST API OR GraphQL 

Next app can fetch data either from external end points or internal end points, next provides a feature to build rest apis.

Page can talk directly to External api 
Next Page---------------------->External API 

Page can talk to NEXT API which intern calls External API 
Next Page-------------|NEXT API-------->External API 

Page can talk to NEXT API Which talks to databases 
Next Page-------------|NEXT API-------->Databases 
.................................

Fetching Data on the Server:

=>Whenever possible, we recommend fetching data on the server. This allows you to:

=>Have direct access to backend data resources (e.g. databases).

=>Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.

=>Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.
=>Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.
=>Reduce client-server waterfalls.
=>Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

Fetching Data Where It's Needed:

If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor forward props between components. Instead, you can use fetch or React cache in the component that needs the data without worrying about the performance implications of making multiple requests for the same data.


Data fetching patterns:
1.On the server, with fetch
2.On the server, with third-party libraries
3.On the client, via a Route Handler
4.On the client, with third-party libraries.


Fetching Data on the Server with fetch:
.......................................

Next.js extends the native "fetch" Web API to allow you to configure the caching and revalidating behavior for each fetch request on the server.
React extends fetch to automatically memoize fetch requests while rendering a React component tree.

You can use fetch with async/await in Server Components, in Route Handlers, and in Server Actions.

Eg:

src/app/todos/page.js 

import Link from "next/link"

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}

export default async function TodosPage() {
    const todos = await fetchTodos()
    return <ul>
        {todos.map(todo => {
            return <>
                <li>
                    <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                </li>

            </>
        })}
    </ul>

}
Task:
Build detail page by fetching todo data from server .
/src/app/todos/[id]/page.js 

export default function TodoPage(props) {
    return <div>
        <h1>Todo Id: {props.params.id}</h1>
    </div>
}
.......................................................................................
                          SSG  - Static Site Generation
.......................................................................................

What is SSG ?
  SSG is type of page rendering.
page can be rendered during request time(SSR) or build time(SSG), build and SSR (ISR)

How to implement SSG ?

Step 1: 
override generateStaticParams
  The generateStaticParams function can be used in combination with dynamic route   segments to statically generate routes at build time instead of on-demand at request time.

todos/[id]/page.js 

URL: http://localhost:3000/todos/1 
  When you hit this url , server prepares page when hit the page - Request time .

What if i want access the page, before i hit. page must have been prepared already and kept in server - SSG 

Step: 
Note: SSG pages only served in prod mode 
 npm run build 
 npm start 

eg:

MasterPage:

src/app/todos/page.js

import Link from "next/link"

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}

export default async function TodosPage() {
    //SSR
    const todos = await fetchTodos()
    return <ul>
        {todos.map(todo => {
            return <>
                <li>
                    <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                </li>

            </>
        })}
    </ul>

}

Details Page where we have to write SSG logic 

src/app/todos/[id]/page.js
export default function TodoPage(props) {
    return <div>
        <h1>Todo Id: {props.params.id}</h1>
    </div>
}

async function fetchTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const response = await fetch(url)
    console.log('fetching...')
    return response.json()
}
//build time page creation.
export async function generateStaticParams() {
    console.log('building')
    const todos = await fetchTodos()
    return todos.map(todo => {
        let id = todo.id.toString()
        return {
            id: id
        }
    })
}

Starting building:
npm run build

npm run build

> data-fetching@0.1.0 build
> next build

   ▲ Next.js 14.0.3

 ✓ Creating an optimized production build
 ✓ Compiled successfully
 ✓ Linting and checking validity of types
   Collecting page data  ...building
fetching...
 ✓ Collecting page data
   Generating static pages (22/206) [=== ]
fetching...
 ✓ Generating static pages (206/206)
 ✓ Collecting build traces
 ✓ Finalizing page optimization

Route (app)                              Size     First Load JS
┌ ○ /                                    139 B            84 kB
├ ○ /_not-found                          876 B          84.7 kB
├ ○ /todos                               6.91 kB        90.8 kB
└ ● /todos/[id]                          140 B            84 kB
    ├ /todos/1
    ├ /todos/2
    ├ /todos/3
    └ [+197 more paths]
+ First Load JS shared by all            83.9 kB
  ├ chunks/472-b67f79dbdd2c1fe1.js       28.7 kB
  ├ chunks/fd9d1056-7b52db27cfdaff1f.js  53.3 kB
  ├ chunks/main-app-25cf34c8082530c3.js  219 B
  └ chunks/webpack-d9f8a4f0dd52fadf.js   1.64 kB


○  (Static)  prerendered as static content
●  (SSG)     prerendered as static HTML (uses getStaticProps)
.......................................................................................
                          Client Side Data Fetching

Patterns:

1.using "fetch" api 
2.using "third party" api  - axios

1.Fetching Data on the Client with Route Handlers(built in api)
..................................................

  If you need to fetch data in a client component, you can call a Route Handler from the client. 
  Route Handlers execute on the server and return the data to the client. This is useful when you don't want to expose sensitive information to the client, such as API tokens.

2.Fetching Data on the client without Route Handler 

If you need to fetch data in a client component, you dont need call a Route Handler from the client. 
 
3.Fetching Data on the Client with third-party libraries:

You can also fetch data on the client using a third-party library such as SWR or React Query

Eg: 
Client component using fetch directly:
......................................

src/app/user/page.js 
import User from "./user"
export default function UsersPage() {
    return <div>
        <h1>Users Page</h1>
        <User></User>
    </div>
}
//client component 
src/app/user/user.jsx 

'use client';
async function getUsers() {
    const url = `https://jsonplaceholder.typicode.com/users`
    const res = await fetch(url)
    if (!res.ok) {
        throw new Error('data is not available')
    }
    return res.json()
}
export default async function User() {
    const users = await getUsers()
    console.log(users)
    return <div>
        <h1>User</h1>
        <div>
            {users.map(user => {
                return <h2>{user.username}</h2>
            })}
        </div>
    </div>
}

Client with thrid party like axios :
steps:
1.just install third party libs like npm install axios 
2.you can use axios function to invoke apis .

Note:
 Whether you are using fetch or axios , the call is not cached , we need to enable cache 
There are many ways ,react 18 provides cache function , you can use that function but still in experimental mode .
you can wrap code in thrid party libs like "SWR" - Stale-While-invalidate

steps:
npm install swr 

src/app/posts/post.jsx 

'use client'
import useSWR from 'swr'

function fetcher(...args) {
    return fetch(...args).then(res => res.json())
}
export default function Post() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetcher)
    if (error) {
        return <div><h1>Failed to return</h1></div>
    }
    if (isLoading) return <div>Loading....</div>
    return <div>
        {
            data.map(post => {
                return <h4>
                    {post.title}
                </h4>
            })
        }
    </div>
}
src/app/posts/page.js
import Post from "./post";

export default function PostPage() {
    return <div>
        <Post></Post>
    </div>
}





























   
 
















